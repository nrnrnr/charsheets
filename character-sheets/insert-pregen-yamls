#!/usr/bin/env lua

local lyaml = require 'lyaml'

-- Command line argument parsing using flags module
local fields = require 'flags'.parser()
  :string('html'):help('HTML template file'):mandated()
  :output_file('output as o'):help('output file (default: stdout)')
  :parse(arg)

-- Collect remaining arguments as YAML files
local yaml_files = {}
local i = 1
while arg[i] do
    table.insert(yaml_files, arg[i])
    i = i + 1
end

if #yaml_files == 0 then
    io.stderr:write("Error: At least one YAML file is required\n")
    os.exit(1)
end

-- Parse YAML content and generate/extract SHEET ORIGIN field
local function process_yaml_file(filename)
    -- Check if file has a reasonable YAML extension
    if not filename:match('%.ya?ml$') then
        io.stderr:write("Warning: " .. filename .. " does not appear to be a YAML file (expected .yaml or .yml extension)\n")
    end

    local file = io.open(filename, 'r')
    if not file then
        io.stderr:write("Error: Could not open file " .. filename .. "\n")
        os.exit(1)
    end

    local yaml_content = file:read('*all')
    file:close()

    -- Parse YAML to check/add SHEET ORIGIN
    local ok, data = pcall(lyaml.load, yaml_content)
    if not ok then
        io.stderr:write("Error: Could not parse YAML in " .. filename .. ": " .. data .. "\n")
        os.exit(1)
    end
    if not data or type(data) ~= 'table' then
        io.stderr:write("Error: " .. filename .. " does not contain valid YAML data\n")
        os.exit(1)
    end

    -- Extract or generate SHEET ORIGIN
    local sheet_origin = data["SHEET ORIGIN"]
    if not sheet_origin then
        sheet_origin = "file " .. filename
        -- Add SHEET ORIGIN to the YAML content
        yaml_content = 'SHEET ORIGIN: "' .. sheet_origin .. '"\n' .. yaml_content
    end

    -- Escape YAML content as JavaScript string literal
    local escaped_yaml = yaml_content:gsub('\\', '\\\\'):gsub('"', '\\"'):gsub('\n', '\\n'):gsub('\r', '\\r')

    return {
        origin = sheet_origin,
        content = escaped_yaml,
        filename = filename
    }
end

-- Read HTML template
local file = io.open(fields.html, 'r')
if not file then
    io.stderr:write("Error: Could not open HTML template file " .. fields.html .. "\n")
    os.exit(1)
end
local html_content = file:read('*all')
file:close()

-- Process YAML files
local yaml_data = {}
for _, filename in ipairs(yaml_files) do
    table.insert(yaml_data, process_yaml_file(filename))
end

-- Build JavaScript array
local js_array = "const EMBEDDED_YAMLS = [\n"
for i, data in ipairs(yaml_data) do
    js_array = js_array .. "    {\n"
    js_array = js_array .. "        origin: \"" .. data.origin:gsub('"', '\\"') .. "\",\n"
    js_array = js_array .. "        content: \"" .. data.content .. "\"\n"
    js_array = js_array .. "    }"
    if i < #yaml_data then
        js_array = js_array .. ","
    end
    js_array = js_array .. "\n"
end
js_array = js_array .. "];\n"

-- Insert JavaScript array into HTML
-- Look for placeholder comment or insert before closing </script> tag
local placeholder = "// EMBEDDED_YAMLS_PLACEHOLDER"
local insertion_point = html_content:find(placeholder)
if insertion_point then
    html_content = html_content:gsub(placeholder, js_array)
else
    -- Fallback: insert before last </script> tag
    local script_end = html_content:find("</script>%s*$")
    if script_end then
        html_content = html_content:sub(1, script_end - 1) .. "\n        " .. js_array .. "\n    </script>"
    else
        io.stderr:write("Error: Could not find insertion point in HTML template\n")
        os.exit(1)
    end
end

-- Output result using flags module output handling
if not fields.output then
    io.write(html_content)
else
    local out_file = io.open(fields.output, 'w')
    if not out_file then
        io.stderr:write("Error: Could not create output file " .. fields.output .. "\n")
        os.exit(1)
    end
    out_file:write(html_content)
    out_file:close()
end
