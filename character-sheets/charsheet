#!/usr/bin/env lua5.1
--------------------------------------------------------------------------
-- yaml-to-dndtex.lua   â€’  Convert character-sheet YAML to LaTeX macros
-- Usage:   lua yaml-to-dndtex.lua  file.yaml   > file.tex
--          cat file.yaml | lua yaml-to-dndtex.lua   > file.tex
--------------------------------------------------------------------------

------------------ classic print functions ---------------------
local stringf = string.format
local function printf(...) return io.stdout:write(stringf(...)) end
local function eprintf(...) return io.stderr:write(stringf(...)) end
local function fprintf(fd, ...) return fd:write(stringf(...)) end
local function dief(...) eprintf(...); os.exit(1) end
local function luaerrorf(...) return error(stringf(...)) end
local function runf(...) return os.execute(stringf(...)) end
local function warnf(...)
  io.stderr:write 'Warning: '; eprintf(...); io.stderr:write '\n'
end
local function outf(out, ...)
  table.insert(out, stringf(...))
  return out
end

-- Global validation errors list
local global_validation_errors = {}

local function verrorf(...)
  local msg = stringf(...)
  table.insert(global_validation_errors, msg)
  eprintf('Validation error: %s\n', msg)
end

----------------------------------------------------------------

local fields = require 'flags'.parser()
  :bool('standalone as s'):help('emit just definitions, not full file')
  :output_file('output as o'):help('where to write if not stdout')
  :string('type as t', 'silverpine'):help('template for character sheet')
  :bool('verbose as v')
  :bool('quiet as q'):help('suppress stdout from pdflatex')
  :bool('strict'):help('halt on field validation errors (default: warn and continue)')
  :string('templates', os.getenv 'CHARSHEETS' or '/home/nr/etc/dnd/resources/character-sheets')
         :help('directory where character-sheet templates live') 
  :numarg(1)
  :parse(arg)

local vprintf = fields.verbose and eprintf or function() end

local pdflatex =
  fields.quiet and 'pdflatex -interaction=nonstopmode -halt-on-error -file-line-error'
    or 'pdflatex -interaction=scrollmode -halt-on-error'



local lyaml  = require "lyaml"

-- -----------------------------------------------------------------------
-- 0.  Make sure we have a load_all() helper
-- -----------------------------------------------------------------------
local yaml_load_all
if lyaml.load_all then
  yaml_load_all = lyaml.load_all          -- native API present
else
  -- Fallback: wrap single-document loader so we still return a list
  yaml_load_all = function(str)
    local ok, doc = pcall(lyaml.load, str)
    if not ok then
      error("lyaml.load failed: "..tostring(doc))
    end
    return { doc }
  end
end

------------------------------------------------------------------------
--
-- Field validation

local function inrange(lo, hi)
  return function (v)
    return tonumber(v) and tonumber(v) >= lo and tonumber(v) <= hi
  end
end

local isnumber = inrange(-math.huge, math.huge)

local function anyvalue(v)
  return true
end

local function optional(p)
  return function (v) 
    -- Handle YAML null, nil, and empty string as valid "empty" values
    if v == '' or v == nil or v == lyaml.null then
      return true
    else
      return p(v)
    end
  end
end

-- Higher-order validator functions
local positive = inrange(1, math.huge)

local function all(p, list)
  for _, v in ipairs(list) do
    local ok, msg = p(v)
    if not ok then
      return ok, msg
    end
  end
  return true
end

local function any(p, list)
  for _, v in ipairs(list) do
    local ok, msg = p(v)
    if ok then
      return ok
    end
  end
  return false
end

local can_be_tab = {
  string = function(v)
             return type(v) == 'string' or type(v) == 'number' or type(v) == 'boolean'
             end,
  number = function(v) return tonumber(v) end,
}
setmetatable(can_be_tab, { __index = function(_, t)
                                       return function(v) return type(v) == t end
                           end})

local function can_be(...)
  local types = { ... }
  return function(v) return any(function(t) return can_be_tab[t](v) end, types) end
end

assert(can_be 'string'('hello'))
assert(can_be 'string'(7))

local function listof(predicate)
  return function(list)
    if not can_be 'table'(list) then
      return false, "must be a list"
    end
    local ok, msg = all(predicate, list)
    if not ok then
      return false, msg or "contains invalid items"
    end
    return true
  end
end

local function nonempty_string(v)
  return can_be 'string'(v) and tostring(v):find('%S')
end

local function empty(v)
  return v == nil
      or type(v) == 'table' and next(v) == nil
      or type(v) == 'string' and not v:find '%S'
      or false
end

assert(nonempty_string 'Arborist')

-- Extract valid equipment categories from category_map (single point of truth)
-- This will be updated after category_map is defined
local valid_equipment_categories

-- Attack field specifications - table-driven approach
local attack_field_specs = {
  { field = 'NAME',   predicate = can_be 'string', required = true },
  { field = 'ATTACK', predicate = can_be 'string', required = true },
  { field = 'DAMAGE', predicate = can_be 'string', required = true },
  { field = 'TYPE',   predicate = can_be 'string', required = true },
  { field = 'RANGE',  predicate = can_be 'string', required = true },
  { field = 'AMMO',   predicate = can_be 'string', required = true },
  { field = 'NOTES',  predicate = can_be 'string', }
}

-- Structure-specific validators
local function validate_attack_entry(attack)
  if not can_be 'table'(attack) then
    return false, "must be a table with attack fields"
  end
  
  -- Check each field according to its specification
  local missing = {}
  local wrong_type = {}
  local optional_errors = {}
  
  for _, spec in ipairs(attack_field_specs) do
    local field = spec.field
    local predicate = spec.predicate
    local required = spec.required
    
    if not attack[field] then
      if required then
        table.insert(missing, field)
      end
    else
      local valid, msg = predicate(attack[field])
      if not valid then
        if required then
          table.insert(wrong_type, string.format("%s (got %s)", field, type(attack[field])))
        else
          table.insert(optional_errors, string.format("%s must be string if present", field))
        end
      end
    end
  end
  
  -- Combine all error messages
  if #missing > 0 or #wrong_type > 0 or #optional_errors > 0 then
    local errors = {}
    if #missing > 0 then
      table.insert(errors, string.format("missing required field(s): %s", table.concat(missing, ", ")))
    end
    if #wrong_type > 0 then
      table.insert(errors, string.format("wrong type for field(s): %s", table.concat(wrong_type, ", ")))
    end
    if #optional_errors > 0 then
      for _, err in ipairs(optional_errors) do
        table.insert(errors, err)
      end
    end
    return false, table.concat(errors, "; ")
  end
  
  return true
end

local function validate_feature_entry(feature)
  local required_fields = {'name', 'description'}
  
  if not can_be 'table'(feature) then
    return false, "must be a table with name and description"
  end
  
  local required_check = function(field)
    return feature[field] and can_be 'string'(feature[field]) and feature[field] ~= ""
  end
  if not all(required_check, required_fields) then
    local missing = {}
    for _, field in ipairs(required_fields) do
      if not required_check(field) then
        table.insert(missing, field)
      end
    end
    return false, string.format("missing required field(s): %s", table.concat(missing, ", "))
  end
  
  return true
end

local function validate_magic_entry(entry)
  if not can_be 'table'(entry) then
    return false, "must be a table"
  end
  
  if entry.level ~= nil then
    -- Level indicator entry
    if can_be 'number'(entry.level) then
      if entry.level < 0 or entry.level > 9 then
        return false, string.format("level must be 0-9, got %d", entry.level)
      end
    elseif can_be 'table'(entry.level) then
      if not entry.level.number or not can_be 'number'(entry.level.number) 
         or entry.level.number < 1 or entry.level.number > 9 then
        return false, string.format("level.number must be 1-9, got %s", tostring(entry.level.number))
      end
      if entry.level.slots and (not can_be 'number'(entry.level.slots) or entry.level.slots < 0) then
        return false, "level.slots must be non-negative number if present"
      end
    else
      return false, "level must be number (0-9) or table with number/slots"
    end
  elseif entry.name then
    -- Spell entry
    if not can_be 'string'(entry.name) or entry.name == "" then
      return false, "spell must have non-empty string name"
    end
    if entry.description and not can_be 'string'(entry.description) then
      return false, "description must be string if present"
    end
  else
    return false, "must have either 'level' or 'name' field"
  end
  
  return true
end

local function validate_equipment_structure(equipment)
  if not can_be 'table'(equipment) then
    return false, "must be a table or list"
  end
  
  -- Empty table is valid
  if next(equipment) == nil then return true end
  
  -- Check if it's a flat list (array-style)
  if #equipment > 0 then
    return listof(can_be 'string')(equipment)
  else
    -- Structured format (object-style) 
    for category, items in pairs(equipment) do
      if not valid_equipment_categories[category:upper()] then
        return false, string.format("invalid equipment category: %s", category)
      end
      local ok, err = listof(can_be 'string')(items)
      if not ok then
        return false, string.format("category %s: %s", category, err or "all items must be strings")
      end
    end
  end
  
  return true
end

-- Main structure validators using listof
local validate_equipment = validate_equipment_structure
local validate_attacks = listof(validate_attack_entry)
local validate_features = listof(validate_feature_entry)
local validate_magic = listof(validate_magic_entry)

-- Validate proficiencies structure (custom logic)
local function validate_proficiency_entry(entry)
  if entry == lyaml.null then
    -- does for blank line
  elseif can_be 'string'(entry) then
    -- Regular proficiency entry - empty strings within list are not allowed
    if entry == "" then 
      return false, "A proficiency cannot be the empty string"
    end
  elseif can_be 'table'(entry) then
    -- Special entry (like proficiencies_skip)
    if entry.proficiencies_skip ~= nil then
      if not can_be 'boolean'(entry.proficiencies_skip) then 
        return false, "proficiencies_skip must be boolean"
      end
    else
      return false, "unknown table entry (expected proficiencies_skip)"
    end
  else
    return false, "proficiency is neither string nor empty"
  end
  return true
end

local validate_proficiencies = listof(validate_proficiency_entry)

local casting_modifier = {
  Bard      = 'CHA',
  Cleric    = 'WIS',
  Druid     = 'WIS',
  Paladin   = 'CHA',
  Ranger    = 'WIS',
  Sorcerer  = 'CHA',
  Warlock   = 'CHA',
  Wizard    = 'INT',
}

local function get_class_from_doc(doc)
  -- Try CLASS & first LEVEL
  if not empty(doc['CLASS & LEVEL']) then
    local class = doc['CLASS & LEVEL']:match('%a+')
    return class
  end
  
  -- Fall back to CLASS field
  if not empty(doc.CLASS) then
    return doc.CLASS:match('%a+')
  end
  
  return nil
end

-- Validate CLASS & LEVEL requirement and parsing
local function validate_class_level_requirement(doc)
  local has_class_level = doc['CLASS & LEVEL'] and doc['CLASS & LEVEL']:find('%S')
  local has_separate = doc.CLASS and doc.CLASS:find('%S') and doc.LEVEL
  
  if not has_class_level and not has_separate then
    return false, "must have either 'CLASS & LEVEL' field or both 'CLASS' and 'LEVEL' fields"
  end
  
  -- If CLASS & LEVEL exists, validate it can be parsed
  if has_class_level then
    local class_level = doc['CLASS & LEVEL']
    local class = class_level:match('%a+')
    local level = class_level:match('%d+%s*$')
    
    if not class then
      return false, "CLASS & LEVEL must contain a valid class name"
    end
    if not level then
      return false, "CLASS & LEVEL must end with a valid level number"
    end
    
    local level_num = tonumber(level)
    if not level_num or level_num < 1 or level_num > 20 then
      return false, string.format("level in CLASS & LEVEL must be 1-20, got %s", level)
    end
  end
  
  return true
end

local field_specs = {
  -- Each entry has: p (predicate), fs (field list), m (message), required (boolean)
  
  -- Required ability scores (1-20)
  { p = inrange(1, 20), m = '%s must be a number in the range 1..20', required = true,
    fs = {'STR', 'DEX', 'CON', 'INT', 'WIS', 'CHA'} },
  
  -- Required basic character info
  { p = nonempty_string, m = '%s is required and must be a non-empty string', required = true,
    fs = {'CHARACTER NAME', 'PLAYER NAME', 'RACE', 'BACKGROUND'} },
  
  -- Required numeric stats
  { p = positive, m = '%s is required and must be a positive number', required = true,
    fs = {'MAX HP', 'ARMOR CLASS', 'PASSIVE PERCEPTION'} },
  
  -- Required structured data
  { p = optional(validate_equipment), m = '%s must be a valid equipment structure', required = true,
    fs = {'EQUIPMENT'} },
  { p = optional(validate_attacks), m = '%s must be a valid attacks list', required = true,
    fs = {'ATTACKS'} },
  { p = optional(validate_features), m = '%s must be a valid features list', required = true,  
    fs = {'FEATURES'} },
  { p = optional(validate_magic), m = '%s must be a valid magic structure', required = true,
    fs = {'MAGIC'} },
  { p = optional(validate_proficiencies), m = '%s must be a valid proficiencies list', required = true,
    fs = {'PROFICIENCIES'} },
    
  -- Optional fields that can be present
  { p = optional(inrange(1, 20)), m = '%s must be a number in the range 1..20',
    fs = {'LEVEL'} },
  { p = optional(positive), m = '%s must be a positive number',  
    fs = {'SPELL DC', 'DOMAIN SPELLS', 'SPELLS KNOWN', 'SORCERY POINTS'} },
  { p = optional(can_be('string', 'number')), m = '%s must be a string or number',
    fs = {'ALIGNMENT', 'HIT DICE', 'INITIATIVE', 'SPEED', 'EXPERIENCE POINTS',
          'CURRENT HIT POINTS', 'SENSES', 'PROFICIENCY BONUS', 'CP', 'SP', 'EP', 'GP', 'PP'} },
  { p = optional(can_be 'string'), m = '%s must be a string',  
    fs = {'AGE', 'DESCRIPTION', 'MOTIVATION', 'SPECIALTY', 'CLASS', 'GM NOTES'} },
  { p = optional(can_be 'boolean'), m = '%s must be a boolean',
    fs = {'PREGENERATED', 'MAGIC SEPARATE'} },
  { p = optional(can_be 'table'), m = '%s must be a table structure',
    fs = {'DESCRIPTION & PERSONALITY', 'TRAITS'} },
}

local validator = { }

do
  for _, spec in ipairs(field_specs) do
    for _, field in ipairs(spec.fs) do
      validator[field] = { 
        predicate = spec.p, 
        message = spec.m,
        required = spec.required or false
      }
    end
  end
end

-- Forward declaration
local value_string

local function table_string(t)
  -- Use Lua's unified syntax: show array elements first, then non-array keys
  local items = {}
  local max_n = table.maxn and table.maxn(t) or 0
  
  -- Add array elements 1, 2, 3, ..., max_n
  for i = 1, max_n do
    table.insert(items, value_string(t[i]))
  end
  
  -- Add non-array keys (keys that are not integers in range 1..max_n)
  local extra_items = {}
  for k, val in pairs(t) do
    if not (type(k) == 'number' and k >= 1 and k <= max_n and k == math.floor(k)) then
      local key_str
      if type(k) == 'string' and k:match('^[%a_][%w_]*$') then
        -- Valid identifier, no quotes needed
        key_str = k
      else
        -- Need to quote or bracket the key
        key_str = "[" .. value_string(k) .. "]"
      end
      table.insert(extra_items, key_str .. "=" .. value_string(val))
    end
  end
  table.sort(extra_items) -- Sort for consistent output
  
  -- Combine array and key-value elements
  for _, item in ipairs(extra_items) do
    table.insert(items, item)
  end
  
  return "{" .. table.concat(items, ", ") .. "}"
end

function value_string(v)
  if type(v) == 'string' then
    return stringf('%q', v)
  elseif type(v) == 'table' then
    -- Handle special cases
    if v == lyaml.null then
      return "null"
    end
    
    return table_string(v)
  else
    return tostring(v)
  end
end

local function validation_message(message, field, v)
  return message:format(stringf('%s [%s]', field, value_string(v)))
end

-- Validation function  
local function validate_document(doc)
  -- Clear global validation errors from previous documents
  for field_name, value in pairs(doc) do
    -- Skip system-generated fields that shouldn't be validated  
    if not field_name:match(' SAVING$') then
      local spec = validator[field_name]
      
      -- Handle font variants dynamically: if "X FONT" and X is valid, treat as optional LaTeX font command
      if not spec and field_name:match(' FONT$') then
        local base_field = field_name:match('(.*) FONT$')
        if base_field and validator[base_field] then
          spec = {
            predicate = optional(function(v) return can_be 'string'(v) and v:match("^\\") end),
            message = '%s must be a LaTeX font command',
          }
        end
      end
      
      if spec then
        -- Handle YAML null and nil as empty values
        local test_value = value
        if value == nil or tostring(value) == 'lyaml.null' then
          test_value = ""
        end
        
        local valid, custom_msg = spec.predicate(test_value)
        if not valid then
          -- Use custom message if provided, otherwise use spec message
          if custom_msg then
            verrorf("%s [%s]: %s", field_name, value_string(value), custom_msg)
          else
            verrorf(validation_message(spec.message, field_name, value))
          end
        end
      elseif fields.strict then
        -- In strict mode, unknown fields are errors
        verrorf("Unknown field: %s", field_name)
      elseif fields.verbose then
        -- In verbose mode, warn about unknown fields
        eprintf("Warning: Unknown field: %s\n", field_name)
      end
    end
  end
  
  if not empty(doc.WIS) and empty(doc['PASSIVE PERCEPTION']) then
    verrorf('WIS present but PASSIVE PERCEPTION missing')
  end

  -- Validate CLASS & LEVEL requirement
  local class_level_valid, class_level_msg = validate_class_level_requirement(doc)
  if not class_level_valid then
    -- Show relevant values for CLASS/LEVEL validation
    local relevant_values = {
      ["CLASS & LEVEL"] = doc["CLASS & LEVEL"],
      CLASS = doc.CLASS,
      LEVEL = doc.LEVEL
    }
    verrorf("CLASS/LEVEL [%s]: %s", value_string(relevant_values), class_level_msg)
  end
end




---------------------------------------------------------------------------
-- 1. TeX-escaping utility
---------------------------------------------------------------------------
local tex_escape_map = {
--  ["\\"] = [[\textbackslash{}]],
  ['Â '] = '~',
  ["&"]  = [[\&]],
  ["%"]  = [[\%]],
  ["$"]  = [[\$]],
  ["#"]  = [[\#]],
  ["_"]  = [[\_]],
--  ["{"]  = [[\{]],
--  ["}"]  = [[\}]],
  ["~"]  = [[\textasciitilde{}]],
  ["^"]  = [[\textasciicircum{}]],
}

local minustab = { ['-'] = [[\textminus]] }

local function escape (s)
  return (tostring(s):gsub("[\\&%%$#_{}~^]", tex_escape_map)
                     :gsub('([%s%d])%-(%d)', [[%1\textminus%2]])
                     :gsub("âˆ’", [[\textminus{}]])
  )
end

local function keyformat(key)
  return (key:gsub('%&', '+'))
end

---------------------------------------------------------------------------
-- 3. Rendering helpers
---------------------------------------------------------------------------
local function render_simple_kv (key, val)
  local fontbase = key:match('(.*) FONT$')
  if fontbase then
    return ([[\setDNDfont{%s}{%s}]]):format(keyformat(fontbase), escape(val))
  else
    return ([[\setDND{%s}{%s}]]):format(keyformat(key), escape(val))
  end
end

local function is_empty_table(v)
  return type(v) == 'table' and next(v) == nil
end

local function render(v)
  if type(v) == 'string' then
    return escape(v)
  elseif type(v) ~= 'table' then
    return tostring(v)
  else
    if v == lyaml.null or v.proficiencies_skip then
      return [[\profskip{}]]
    elseif v.smallskip then
      return [[\smallskip{}]]
    elseif v.medskip then
      return [[\medskip{}]]
    elseif v.Languages then
      return v.Languages
    elseif v.Armor then
      return string.format('%s Armor', v.Armor)
    elseif v.Weapons then
      return string.format('%s Weapons', v.Weapons)
    else
      return 'whut?: ' .. (require 'inspect'.image(v))
    end
  end
end

local function render_item(v)
  if is_empty_table(v) then -- blank list entry
    return [[\profskip{}]]
  else
    local s = render(v)
    if s:find [[\profskip]] or s:find [[\medskip]] or s:find [[\smallskip]]
    or s:find [[\bigskip]]
    then
      return s
    else
      return ([[\item %s]]):format(s)
    end
  end
end

local function render_item_list (key, list)
  local items = {}
  for _,v in ipairs(list) do
    table.insert(items, render_item(v))
  end
  return ([[\setDND{%s}{%s}]]):format(keyformat(key), table.concat(items, "\n"))
end

local function render_attack_record (rec)
  local parts = {}
  if type(rec.ATTACK) == 'number' then
    rec.ATTACK = stringf('%+d', rec.ATTACK)
  end
  for _, k in ipairs { "NAME", "ATTACK", "DAMAGE", "TYPE", "RANGE", "AMMO", 'NOTES' }
  do
    local tex_key = k
    if k == 'AMMO' and tonumber(rec[k]) then
      tex_key = 'GRAYAMMO'
    end
    outf(parts, "%s={%s}", escape(tex_key), escape(rec[k] or ""))
  end
  return ([[\dndkeys{%s}]]):format(table.concat(parts, ","))
end

local function render_generic_record (rec)
  local parts = {}
  for k,v in pairs(rec) do
    outf(parts, "%s={%s}", escape(k), escape(v))
  end
  table.sort(parts)
  return ([[\dndkeys{%s}]]):format(table.concat(parts, ","))
end

local function note(elem)
  return elem.NOTE  and elem.NOTE :find '%S' and elem.NOTE or
         elem.NOTES and elem.NOTES:find '%S' and elem.NOTES
end



local function render_struct_list (key, list)
  vprintf('rendering struct for %s\n', key)
  local out = {}
  local notes_header_out = false
  for _,elem in ipairs(list) do
    if type(elem) ~= "table" then
      outf(out, [[\item %s]], escape(tostring(elem)))
    elseif elem.level and not next(elem, 'level') then
      if type(elem.level) == 'table' then
        outf(out, [[\multicolumn2{@{}l@{}}{\spellslevel[%s]{%s}}\\]], elem.level.slots, elem.level.number)
      else
        outf(out, [[\multicolumn2{@{}l@{}}{\spellslevel{%s}}\\]], escape(elem.level))
      end
    elseif elem.name and elem.description and not elem.ATTACK
        or key == 'MAGIC'
    then
      outf(out, [[\described{%s}{%s}]],
           escape(elem.name or ''), escape(elem.description or ''))
    elseif elem.ATTACK then
      vprintf('rendering an attack\n')
      table.insert(out, render_attack_record(elem))
    else
      table.insert(out, render_generic_record(elem))
    end
  end
  for _,elem in ipairs(list) do
    if elem.ATTACK and note(elem) then
      if not notes_header_out then
        table.insert(out, [[\notesheader]])
        notes_header_out = true
      end
      outf(out, [[\attacknote{%s}{%s}]], elem.NAME, note(elem))
    end
  end

  return ([[\setDND{%s}{%s}]]):format(keyformat(key), table.concat(out, "%\n"))
end

---------------------------------------------------------------------------
-- 3.5. Equipment string list parsing
---------------------------------------------------------------------------

local category_map = {
  ["heavy weapon"] = "HEAVY WEAPONS",
  ["normal weapon"] = "NORMAL WEAPONS",
  ["light weapon"] = "LIGHT WEAPONS",
  ["shield"] = "SHIELDS",
  ["heavy armor"] = "HEAVY ARMOR",
  ["heavy armour"] = "HEAVY ARMOR",
  ["normal armor"] = "MEDIUM ARMOR",
  ["normal armour"] = "MEDIUM ARMOR", 
  ["medium armor"] = "MEDIUM ARMOR",
  ["medium armour"] = "MEDIUM ARMOR",
  ["light armor"] = "LIGHT ARMOR",
  ["light armour"] = "LIGHT ARMOR",
  ["heavy item"] = "HEAVY ITEMS",
  ["slotted item"] = "SLOTTED ITEMS",
  ["free item"] = "SMALL ITEMS",
  ["small item"] = "SMALL ITEMS",
}

-- Extract valid equipment categories from category_map (single point of truth)
valid_equipment_categories = {}
for _, category in pairs(category_map) do
  valid_equipment_categories[category] = true
end

local function strip_s(s)
  if s:sub(-1) == 's' then
    return s:sub(1, -2)
  else
    return s
  end
end

local function category(s)
  return category_map[strip_s(s:lower())]
end

local function heuristic_category(s)
  return 'SLOTTED ITEMS'
end

---------------------------------------------------------------------------
-- 3.6. Equipment format detection and processing
---------------------------------------------------------------------------

local function is_string_list_with_categories(equipment_data)
  if type(equipment_data) ~= "table" or #equipment_data == 0 then
    return false
  end
  if type(equipment_data[1]) ~= "string" and type(equipment_data[1]) ~= "number" then
    return false
  end
  -- Check if any item has category syntax
  local has_category_syntax = function(item)
    return type(item) == "string" and (item:match(":") or item:match("^-"))
  end
  return any(has_category_syntax, equipment_data)
end

local function is_structured_object(equipment_data)
  if type(equipment_data) ~= "table" or #equipment_data > 0 then
    return false
  end
  -- Has string keys (categories) rather than numeric indices
  return next(equipment_data) ~= nil
end


-- Helper functions for equipment processing
local function extract_weight_arg(category, equipment_item)
  if category == "HEAVY ITEMS" then
    local stones = equipment_item:match("%((%d+) stones?%)")
    if stones then
      return string.format("[%d]", tonumber(stones) * 10)
    end
  end
  return ""
end

local function add_equipment_item(category, equipment_item, lines, flattened_equipment)
  local weight_arg = extract_weight_arg(category, equipment_item)
  table.insert(lines, string.format("\\addDNDitem%s{%s}{%s}", 
    weight_arg, category:gsub('&', '+'), escape(equipment_item)))
  table.insert(flattened_equipment, render_item(equipment_item))
end

-- Process structured equipment and generate LaTeX output
local function emit_structured_equipment(structured_equipment, lines)
  local flattened_equipment = {}
  
  -- Process all categories
  for category, items in pairs(structured_equipment) do
    if type(items) == "table" and #items > 0 then
      if category ~= "UNCATEGORIZED" then
        -- Categorized items get \addDNDitem commands
        for _, equipment_item in ipairs(items) do
          add_equipment_item(category, equipment_item, lines, flattened_equipment)
        end
      else
        -- Uncategorized items only go to flattened list
        for _, equipment_item in ipairs(items) do
          table.insert(flattened_equipment, render_item(equipment_item))
        end
      end
    end
  end
  
  -- Emit flattened equipment list
  if #flattened_equipment > 0 then
    table.insert(lines, string.format("\\setDND{EQUIPMENT}{%s}", 
      table.concat(flattened_equipment, "\n")))
  else
    table.insert(lines, "\\setDND{EQUIPMENT}{}")
  end
end

-- Parse equipment from a list of strings into structured format
-- Supports both inline format ("NORMAL WEAPONS: Longsword") and
-- block format ("NORMAL WEAPONS:", "- Longsword", "- Shortbow")
local function parse_equipment_strings(lines)
  local equipment = {}
  local i = 1

  local function add(category, item)
    equipment[category] = equipment[category] or {}
    table.insert(equipment[category], item)
  end
  
  while i <= #lines do
    -- see grammar for EQUIPMENT in YAML.md
    local line = lines[i]:gsub("^%s+", ""):gsub("%s+$", "") -- trim whitespace
    local block_header = line:match("^(.+):$")
    
    if line == "" then
      -- Skip empty lines
      i = i + 1
    elseif block_header and category(block_header) then
      -- Block format category header: "CATEGORY:"
      local cat = category(block_header)
      equipment[cat] = equipment[cat] or {} -- populate even if no items follow
      i = i + 1
      while i <= #lines and lines[i]:find '^%s*%-%s' do
        local item = lines[i]:gsub("^%s*%-%s+", ""):gsub("%s+$", "")
        add(cat, item)
        i = i + 1
      end
    elseif block_header then
      eprintf("Warning: Unknown equipment category %q\n", block_header)
      i = i + 1
    elseif line:match("^%S.*:") then
      -- Inline format: "CATEGORY: Item Name"
      local cat, item = assert(line:match("^([^:]-)%s*:%s*(.*)$"))
      if category(cat) then
        add(category(cat), item)
      else
        eprintf("Warning: Unknown equipment category %q in line %q\n", cat, line)
      end
      i = i + 1
    else
      add(heuristic_category(line), line)
      i = i + 1
    end
  end
  return equipment
end

-- Convert any equipment format to unified structured format
local function equipment(equipment_data)
  if is_string_list_with_categories(equipment_data) then
    return parse_equipment_strings(equipment_data)
  elseif is_structured_object(equipment_data) then
    return equipment_data -- already in structured format
  elseif type(equipment_data) == "table" and #equipment_data > 0 then
    -- Traditional string list - put everything in heuristic category
    local result = {}
    result[heuristic_category()] = equipment_data
    return result
  else
    return {} -- empty equipment
  end
end

-- Helper function to visualize table structure for debugging
local function visualize_table(t, indent)
  indent = indent or 0
  local spaces = string.rep("  ", indent)
  local result = {}
  for k, v in pairs(t) do
    if type(v) == "table" then
      table.insert(result, spaces .. tostring(k) .. " = {")
      table.insert(result, visualize_table(v, indent + 1))
      table.insert(result, spaces .. "}")
    else
      table.insert(result, spaces .. tostring(k) .. " = " .. tostring(v))
    end
  end
  return table.concat(result, "\n")
end

-- Local recursive table equality comparison
local function table_eq(t1, t2)
  if t1 == t2 then
    return true
  elseif type(t1) ~= 'table' or type(t2) ~= 'table' then
    return false
  else
    for k, v in pairs(t1) do
      if not table_eq(v, t2[k]) then
        return false
      end
    end
    for k, v in pairs(t2) do
      if t1[k] == nil then
        return false
      end
    end
    return true
  end
end

-- Convert structured equipment back to string list format
local function unparse_equipment_structure(structured_equipment)
  local lines = {}
  
  -- Helper to capitalize first letter of each word
  local function capitalize(s)
    return s:gsub("(%a)([%w_']*)", function(first, rest)
      return first:upper() .. rest:lower()
    end)
  end
  
  -- Helper to get singular form and proper capitalization
  local function format_category_name(category)
    return capitalize(category:lower():gsub("s$", ""))
  end
  
  for category, items in pairs(structured_equipment) do
    if type(items) == "table" then
      if #items == 1 then
        -- Single item: use inline format
        local formatted_category = format_category_name(category)
        table.insert(lines, formatted_category .. ": " .. items[1])
      else
        -- Multiple items or empty: use block format
        local formatted_category = format_category_name(category)
        table.insert(lines, formatted_category .. "s:")
        for _, item in ipairs(items) do
          table.insert(lines, "- " .. item)
        end
      end
    end
  end
  
  return lines
end

-- Round-trip validation function
local function validate_equipment_parsing(structured_equipment)
  -- Skip validation for empty structures
  if not structured_equipment or (type(structured_equipment) == "table" and next(structured_equipment) == nil) then
    return structured_equipment
  end
  
  -- Skip round-trip validation if equipment structure is invalid
  local valid, _ = validate_equipment(structured_equipment)
  if not valid then
    return structured_equipment  -- Return invalid structure as-is, validation errors already reported
  end
  
  -- Unparse to string list format
  local unparsed_lines = unparse_equipment_structure(structured_equipment)
  
  -- Parse it back
  local reparsed_structure = parse_equipment_strings(unparsed_lines)
  
  -- Compare with original
  if not table_eq(structured_equipment, reparsed_structure) then
    error(string.format("Equipment round-trip validation failed!\nOriginal:\n%s\n\nUnparsed lines:\n%s\n\nReparsed:\n%s", 
      visualize_table(structured_equipment),
      table.concat(unparsed_lines, "\n"),
      visualize_table(reparsed_structure)))
  end
  
  return structured_equipment
end

---------------------------------------------------------------------------
-- 4. Convert a single YAML mapping to LaTeX lines
---------------------------------------------------------------------------
local function convert_mapping (map)
  local lines = {}

  do -- proficiency
    local level = tonumber(map.LEVEL)
    local prof = level and (2 + math.floor((level - 1) / 4)) or 2
    outf(lines, [[\setcounter{proficiency bonus}{%d}]], prof)
  end

  -- Iterate in original order if lyaml preserved it (omap style)
  local keys = {}
  if map.n and map[1] and type(map[1])=="table" and map[1][1] then
    for i=1,map.n do table.insert(keys, map[i][1]) end
  else
    for k in pairs(map) do table.insert(keys, k) end
    table.sort(keys)               -- fallback: deterministic but arbitrary
  end

  for _,k in ipairs(keys) do
    local v = map[k]
    local t = type(v)
    if k == "EQUIPMENT" and t == "table" then
      emit_structured_equipment(validate_equipment_parsing(equipment(v)), lines)
    elseif t=="string" or t=="number" or t=="boolean" then
      table.insert(lines, render_simple_kv(k, tostring(v)))
    elseif t=="table" then
      if #v > 0 and (type(v[1])=="string" or type(v[1])=="number") then
        table.insert(lines, render_item_list(k, v))
      else
        table.insert(lines, render_struct_list(k, v))
      end
    end
  end
  return table.concat(lines, "\n")
end

---------------------------------------------------------------------------
-- 5. Entry point
---------------------------------------------------------------------------
local function slurp(filename)
  if filename == '-' or filename == '.' or not filename then
    return io.stdin:read("*a")
  else
    local f = assert(io.open(filename, "r"))
    local txt = f:read("*a"); f:close(); return txt
  end
end

local saving_throw_proficiencies = {
  Barbarian = { "Strength", "Constitution" },
  Bard      = { "Dexterity", "Charisma" },
  Cleric    = { "Wisdom", "Charisma" },
  Druid     = { "Intelligence", "Wisdom" },
  Fighter   = { "Strength", "Constitution" },
  Monk      = { "Strength", "Dexterity" },
  Paladin   = { "Wisdom", "Charisma" },
  Ranger    = { "Strength", "Dexterity" },
  Rogue     = { "Dexterity", "Intelligence" },
  Sorcerer  = { "Constitution", "Charisma" },
  Warlock   = { "Wisdom", "Charisma" },
  Wizard    = { "Intelligence", "Wisdom" }
}


local function extend(doc)
  local class = doc.CLASS or (doc['CLASS & LEVEL'] or ''):match '%a+' or ''
  doc.CLASS = class
  
  -- Extract SPECIALTY from "CLASS & LEVEL" if SPECIALTY is absent
  if not doc.SPECIALTY and doc['CLASS & LEVEL'] then
    doc.SPECIALTY = doc['CLASS & LEVEL']:match '%a+%s*%(([^)]+)%)'
  end
  
  -- Extract LEVEL from "CLASS & LEVEL" if LEVEL is absent
  doc.LEVEL = doc.LEVEL or
              doc['CLASS & LEVEL'] and doc['CLASS & LEVEL']:match '%d+%s*$' or
              nil
  
  -- Only build "CLASS & LEVEL" if we have separate CLASS/LEVEL/SPECIALTY fields
  if doc.CLASS and doc.LEVEL and not doc['CLASS & LEVEL'] then
    if doc.SPECIALTY and doc.SPECIALTY:find '%S' then
      doc['CLASS & LEVEL'] = stringf('%s (%s) %s', class, doc.SPECIALTY, doc.LEVEL)
    else
      doc['CLASS & LEVEL'] = stringf('%s %s', class, doc.LEVEL)
    end
  end
  
  local p = saving_throw_proficiencies[class]
  if p then
    for _, prof in ipairs(p) do
      doc[stringf('%s SAVING', prof:sub(1,3):upper())] = true
    end
  end

  -- Handle SPELL DC calculation and validation
  if not empty(doc.MAGIC) then
    local modifier = casting_modifier[class]
    if modifier and not empty(doc[modifier]) then
      -- Calculate spell DC: 8 + proficiency bonus + ability modifier
      local ability_score = tonumber(doc[modifier])
      local level = tonumber(doc.LEVEL) or 1
      local prof_bonus = 2 + math.floor((level - 1) / 4)
      local ability_modifier = math.floor((ability_score - 10) / 2)
      local calculated_dc = 8 + prof_bonus + ability_modifier
      
      if not empty(doc['SPELL DC']) then
        -- Validate existing SPELL DC
        local existing_dc = tonumber(doc['SPELL DC'])
        if existing_dc and existing_dc ~= calculated_dc then
          verrorf('SPELL DC mismatch: got %d, expected %d (8 + prof %d + %s mod %+d)', 
                  existing_dc, calculated_dc, prof_bonus, modifier, ability_modifier)
        end
      else
        -- Set calculated SPELL DC
        doc['SPELL DC'] = calculated_dc
      end
    end
  end

  -- Handle PASSIVE PERCEPTION calculation and validation
  if not empty(doc.WIS) then
    -- Check if character has Expertise feature (case-insensitive)
    local has_expertise = false
    if doc.FEATURES and type(doc.FEATURES) == "table" then
      for _, feature in ipairs(doc.FEATURES) do
        if type(feature) == "table" and feature.name and 
           type(feature.name) == "string" and feature.name:lower():find('expertise') then
          has_expertise = true
          break
        end
      end
    end
    
    if not has_expertise then
      -- Calculate passive perception: 10 + WIS modifier + proficiency bonus
      local wis_score = tonumber(doc.WIS)
      local level = tonumber(doc.LEVEL) or 1
      local prof_bonus = 2 + math.floor((level - 1) / 4)
      local wis_modifier = math.floor((wis_score - 10) / 2)
      local calculated_pp = 10 + wis_modifier + prof_bonus
      
      if not empty(doc['PASSIVE PERCEPTION']) then
        -- Validate existing PASSIVE PERCEPTION
        local existing_pp = tonumber(doc['PASSIVE PERCEPTION'])
        if existing_pp and existing_pp ~= calculated_pp then
          verrorf('PASSIVE PERCEPTION mismatch: got %d, expected %d (10 + WIS mod %+d + prof %d)', 
                  existing_pp, calculated_pp, wis_modifier, prof_bonus)
        end
      else
        -- Set calculated PASSIVE PERCEPTION
        doc['PASSIVE PERCEPTION'] = calculated_pp
      end
    end
  end

  return doc
end

local function contents(filename)
  local f, msg = io.open(filename, 'r')
  if not f then return f, msg end
  local s, msg = f:read '*a'
  if not s then return s, string.format('%s: %s', filename, msg) end
  f:close()
  return s
end

local function set_contents(filename, s)
  local f, msg = io.open(filename, 'w')
  if not f then return f, msg end
  local s = assert(f:write(s))
  f:close()
  return s or true
end

local quote_me = '[^%w%+%-%=%@%_%/%.%:]' -- easier to complement what doesn't need quotes
local strfind = string.find

local function dirname(s) -- also returns basename as second result
  s = s:gsub('/$', '')
  local dir, base = s:match '^(.*)/([^/]*)$'
  if not dir then
    return '.', s
  elseif dir == '' then
    return '/', base
  else
    return dir, base
  end
end


function osquote(s)
  -- Returns string s with whatever markup is needed to quote it 
  -- to the POSIX shell.

  if strfind(s, quote_me) or s == '' then
    return "'" .. string.gsub(s, "'", [['"'"']]) .. "'"
  else
    return s
  end
end

local function fill_template(assignments)
  local pathname = stringf('%s/%s.tex', fields.templates, fields.type)
  local template, msg = contents(pathname)
  if not template then
    eprintf('%s\n', msg)
    os.exit(1)
  else
    local bracketed_splash = stringf('{%s/splash.png}', fields.templates)
    return (template:gsub('\n%s*\\input%b{}', assignments)
                    :gsub('%{splash.png%}', bracketed_splash)
           )
  end
end

local function emit(assignments)
  local output = fields.standalone and assignments or fill_template(assignments)

  if not fields.output then
    io.stdout:write(assignments, '\n')
  elseif fields.output:find '%.tex$' then
    set_contents(fields.output, output)
  elseif fields.output:find '%.pdf$' then
    local tex = fields.output:gsub('%.pdf$', '.tex')
    set_contents(tex, output)
    local rc = runf('%s -output-directory %s %s',
                    pdflatex, osquote(dirname(fields.output)), osquote(tex))
    if rc ~= 0 then
      os.exit(rc)
    end
  end
end

local main = function(arg)
  local yaml_text = slurp(arg[1])
  for _,doc in ipairs(yaml_load_all(yaml_text)) do
    if type(doc) == 'string' then
      eprintf("YAML loaded as string %q.\n", doc)
      os.exit(1)
    end
    
    -- Validate document before processing
    validate_document(doc)
    if #global_validation_errors > 0 then
      if fields.strict then
        eprintf("Validation failed in strict mode. Exiting.\n")
        os.exit(1)
      else
        eprintf("Validation warnings encountered. Continuing...\n")
        -- In non-strict mode, accumulate validation errors in the document
        doc['VALIDATION ERRORS'] = global_validation_errors
      end
    end
    
    extend(doc)
    if type(doc)=="table" then
      emit(convert_mapping(doc))
    end
  end
end


main(arg)
