\RequirePackage[margin=7mm,top=4mm]{geometry}
\RequirePackage{tikz}
\RequirePackage{times}
\RequirePackage{xcolor}
\RequirePackage{colortbl}
\RequirePackage{environ}
\RequirePackage{tabularx}
\RequirePackage{booktabs}
\RequirePackage{calc}
\RequirePackage{ifthen}
\RequirePackage{suffix}
\RequirePackage{xstring}
\RequirePackage{ifmtarg}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes}
\usepgflibrary{intersections}

% Define colors for different sections
\colorlet{stats}{blue!10!white}
\colorlet{proficiencies}{yellow!12!white}
\colorlet{attacks}{orange!25!white}
\colorlet{magic}{red!12!white}
\colorlet{features}{magenta!16!white}
\colorlet{playername}{green!90!yellow!8!white}
\colorlet{splashfield}{playername!97.5!black}
\colorlet{teal}{blue!40!green}
\colorlet{equipment}{playername}
\colorlet{hit points background}{gray!40!white}
\colorlet{features background}{white!60!features}

\DeclareOption{nocolor}{\dndnocolor}
\newcommand\dndnocolor{%
  \colorlet{stats}{white}%
  \colorlet{proficiencies}{white}%
  \colorlet{attacks}{white}%
  \colorlet{magic}{white}%
  \colorlet{features}{white}%
  \colorlet{equipment}{white}%
  \colorlet{features background}{white}
  \colorlet{playername}{white}
  \colorlet{splashfield}{white!96!black}
}

\newcommand\@fboxzero[1]{{\fboxsep=0pt \fbox{#1}}}

\newdimen\slotblockwidth % width of a slot on the equipment page
\slotblockwidth=60mm

% Define minimum label separation key for labeled rectangle shape
\pgfkeys{/pgf/minimum label sep/.initial=\baselineskip}
\tikzset{minimum label sep/.code=\pgfkeys{/pgf/minimum label sep={#1}}}

\tikzset{ % convenience
    height/.style={minimum height=#1},
    width/.style={minimum width=#1}
}

\tikzset{
  minimum label sep=8pt,
  labeled decorated stub rectangle/.style={
    shape=decorated labeled stub rectangle,
  },
  labeled decorated clipped rectangle/.style={
    shape=decorated labeled clipped rectangle,
  },
  dndbox/.style={ % box intended for sections and such
    decorated stub rectangle,
    stub radius=2.3mm,
    line width=1.2pt,
    draw,
  },
  dnd max hp/.style={ % hold max NP, initiative, speed, and so on
    dndbox,
    labeled decorated clipped rectangle,
    font=\LARGE,
    fill=white,
    minimum height=18mm,
    minimum width=24mm,
  },
  dndencumbrance/.style={
    dnd max hp,
    minimum width=40mm,
    font={\large\boldmath\bfseries\sffamily},
  },
  statbox/.style={ % 
    dndbox,
    stub rectangle,
    stub radius=1.5mm,
    minimum width=18mm,
    minimum height=20mm,
    fill=none,
  },
  slotblock/.style={
    minimum width=\slotblockwidth,
    outer sep=0pt,
  },
}

\tikzset{coin/.style={
   dndbox,
   long octagon,
   long octagon angle=45,
   long octagon end height=2.5mm,
   width=15.5mm,
   height=7.5mm
}}

\tikzset{
  magic/.style={
    fill=magic,
  },
  attacks/.style={
    fill=attacks,
  },
  features/.style={
    fill=features,
  },
  equipment/.style={
    fill=equipment,
  },
  proficiencies/.style={
    dndbox,
    labeled decorated stub rectangle,
    fill=proficiencies,
  },
}


\newenvironment{charsheet}[1][]
  {\begin{tikzpicture}[x=1cm,y=1cm, node distance=5pt,outer sep=0pt,
    #1]
   \useasboundingbox (0,0) rectangle (\textwidth,\textheight);
   \path (current bounding box.north) coordinate (top)
         (current bounding box.south east) coordinate (bottom right)
         (current bounding box.south west) coordinate (bottom left)
         (current bounding box.north east) coordinate (top right)
         (current bounding box.north west) coordinate (top left)
   ;
  }
  {\end{tikzpicture}\ignorespacesafterend}

% extensions to positioning library

%
% \tikz@lib@place@handle@{spec}{new anchor}{x multiplier}{y multiplier}{old anchor}
%                              {factor}%
%
%  place anchor of new node at `(x,y)*node distance` from given anchor of old node
%
%  x and y are signed
%
%  node distance is multiplied by factor
%
\tikzset{
    right of base/.code={%
        \tikz@lib@place@handle@{#1}{base west}{1}{0}{base east}{1.0}%
    },
    left of base/.code={%
        \tikz@lib@place@handle@{#1}{base east}{-1}{0}{base west}{1.0}%
    },
    inside south east corner/.code={%
        \tikz@lib@place@handle@{#1}{south east}{-1}{1}{south east}{1}%
    },
    inside south west corner/.code={%
        \tikz@lib@place@handle@{#1}{south west}{1}{1}{south west}{1}%
    },
    inside north east corner/.code={%
        \tikz@lib@place@handle@{#1}{north east}{-1}{-1}{north east}{1}%
    },
    inside north west corner/.code={%
        \tikz@lib@place@handle@{#1}{north west}{1}{-1}{north west}{1}%
    },
    below right corner/.code={%
        \tikz@lib@place@handle@{#1}{north east}{0}{-1}{south east}{1.0}%
    },
    below top/.code={%
      \tikz@lib@place@handle@{#1}{north}{0}{-1}{north}{1.0}%
    },
    above left corner/.code={%
        \tikz@lib@place@handle@{#1}{south west}{0}{1}{north west}{1.0}%
    },
    below left corner/.code={%
        \tikz@lib@place@handle@{#1}{north west}{0}{-1}{south west}{1.0}%
    },
    above right corner/.code={%
        \tikz@lib@place@handle@{#1}{south east}{0}{1}{north east}{1.0}%
    },
    right of upper corner/.code={%
        \tikz@lib@place@handle@{#1}{north west}{1}{0}{north east}{1.0}%
    },
    right of lower corner/.code={%
        \tikz@lib@place@handle@{#1}{south west}{1}{0}{south east}{1.0}%
    },
    left of upper corner/.code={%
        \tikz@lib@place@handle@{#1}{north east}{-1}{0}{north west}{1.0}%
    },
    left of lower corner/.code={%
        \tikz@lib@place@handle@{#1}{south east}{-1}{0}{south west}{1.0}%
    },
}

% --- run-later list ----------------------------------------


\newcommand{\slotsliteral}[2][1.5mm]{% 
  % connected dots, use for spell slots, hit dice, etc
  \hbox{%
    \begin{tikzpicture}[baseline=(circle-base), thick,inner sep=0pt, outer sep=0pt]
      \ifnum#2>0
        % Create first circle node
        \node[circle, draw, minimum size=3.2mm] (circle-1) at (0,1.6mm) {};
        \path (circle-1.south) +(0mm,1pt) coordinate (circle-base); % looks better
        \def\prevnode{circle-1}%
        \ifnum#2>1
          % Create remaining circle nodes and connect them
          \foreach \i in {2,...,#2} {
            % Create circle node positioned relative to previous node
            \edef\go{%  avoid speculating about just how tikz expands
            \noexpand\node (circle-\i)
                  [circle, draw, minimum size=3.2mm, right=#1 of \prevnode] {};
            }%
            \go
            
            % Draw double line between consecutive circles
            \draw[double, double distance=0.6mm] (\prevnode) -- (circle-\i);
            \xdef\prevnode{circle-\i}%
          }
        \fi
      \fi
    \end{tikzpicture}%
  }%
}


\newcounter{slotcounter}
\newcounter{slotstemp}
\newcommand{\slots}[1]{%
  \setcounter{slotstemp}{#1}%
  \expandafter\slotsliteral\expandafter{\value{slotstemp}}\relax%
}

%%%%%%%%%%%%

% Vertical spacing between rows of slots
\newdimen\slotrowsep
\slotrowsep=2pt

% Helper counters
\newcount\tempcount
\newcount\remaining
\newcount\minrowstempcount
\newcounter{minrowsresult}
\newcounter{rowswiththree}
\newcounter{rowswithfour}
\newcounter{buildrows}

\newif\iffirstisfour

% Helper function that computes minrows and stores in counter
\newcommand{\setminrowsresult}[1]{%
  \ifnum#1<5
    \setcounter{minrowsresult}{1}%
  \else
    % Try with first row = 3
    \setminrowsresult{\numexpr#1-3\relax}%
    \setcounter{rowswiththree}{\value{minrowsresult}}%
    % Try with first row = 4  
    \setminrowsresult{\numexpr#1-4\relax}%
    \setcounter{rowswithfour}{\value{minrowsresult}}%
    % Return the minimum (plus 1 for the current row)
    \ifthenelse{\value{rowswiththree}>\value{rowswithfour}}{%
      \setcounter{minrowsresult}{\value{rowswithfour}+1}%
      \firstisfourtrue
    }{%
      \setcounter{minrowsresult}{\value{rowswiththree}+1}%
      \firstisfourfalse
    }%
  \fi
}

% User-facing function that returns the result as text
\newcommand{\minrows}[1]{%
  \setminrowsresult{#1}%
  \arabic{minrowsresult}%
}

\newcommand\fourslots{\slotsliteral[1.0mm]{4}} % closer together


% Main macro
\newcommand{\stackslots}[1]{%
  \noindent
  \setcounter{slotcounter}{#1}%
  \ifnum\value{slotcounter}=0
    \hbox{}%
  \else
    \vbox{\buildoptimalrows{\arabic{slotcounter}}}%
  \fi
}



% Build optimal row composition using same recursive logic
\newcommand{\buildoptimalrows}[1]{%
  \setcounter{buildrows}{#1}%
  \ifthenelse{\value{buildrows}<5}{%
    % Base case: 1-4 slots in single row
    \hbox to 0pt{\hss
      \ifthenelse{\value{buildrows}=4}{\fourslots}{\slots{\arabic{buildrows}}}%
      \hss}%
  }{%
    % Recursive case: decide between first row of 3 or 4
    % Try with first row = 3
    \setminrowsresult{\value{buildrows}}%
    \iffirstisfour
       \hbox to 0pt{\hss\fourslots\hss}%
       \buildoptimalrows{\value{buildrows}-4}%
    \else
       \hbox to 0pt{\hss\slots{3}\hss}%
       \buildoptimalrows{\value{buildrows}-3}%
    \fi
  }%
}


% \renderstones{<tenths>} - Render weight in stones with fractions
\newcommand{\renderstones}[1]{%
  \pgfmathsetmacro{\tenths}{int(#1)}%
  \pgfmathsetmacro{\remainder}{int(mod(\tenths,10))}%
  \ifnum\remainder=0\relax
    % Multiple of 10 - display whole stones
    \pgfmathparse{int(\tenths/10)}%
    \edef\stonesrendered{\pgfmathresult}%
    \ensuremath{\stonesrendered}%
  \else
    \pgfmathsetmacro{\remainderfive}{int(mod(\tenths,5))}%
    \ifnum\remainderfive=0\relax
      % Multiple of 5 but not 10 - display with halves
      \pgfmathparse{int(\tenths/10)}%
      \let\wholestones\pgfmathresult%
      \ifnum\wholestones=0\relax
        \ensuremath{\frac{1}{2}}%
      \else
        \ensuremath{\wholestones\frac{1}{2}}%
      \fi
    \else
      \pgfmathsetmacro{\remaindertwo}{int(mod(\tenths,2))}%
      \ifnum\remaindertwo=0\relax
        % Multiple of 2 but not 10 - display with fifths
        \pgfmathparse{int(\tenths/10)}%
        \let\wholestones\pgfmathresult%
        \pgfmathparse{int(mod(\tenths,10)/2)}%
        \let\fifths\pgfmathresult%
        \ifnum\wholestones=0\relax
          \ensuremath{\frac{\fifths}{5}}%
        \else
          \ensuremath{\wholestones\frac{\fifths}{5}}%
        \fi
      \else
        % Resort to tenths
        \pgfmathparse{int(\tenths/10)}%
        \let\wholestones\pgfmathresult%
        \pgfmathparse{int(mod(\tenths,10))}%
        \let\tenthspart\pgfmathresult%
        \ifnum\wholestones=0\relax
          \ensuremath{\frac{\tenthspart}{10}}%
        \else
          \ensuremath{\wholestones\frac{\tenthspart}{10}}%
        \fi
      \fi
    \fi
  \fi
}

% Macro to return "stone" or "stones" based on weight in tenths
\newcommand{\stonesplural}[1]{%
  \ifnum#1>10\relax
    stones%
  \else
    stone%
  \fi
}



\newenvironment{proflist}
  {\clubpenalty=10000
   \widowpenalty=10000
   \begin{list}{}{%
      \advance\@itemdepth\@ne
      \raggedright
      \setlength{\leftmargin}{16pt}% no indentation
      \setlength{\labelwidth}{0pt}%
      \setlength{\labelsep}{0pt}%
      \setlength{\itemindent}{-10pt}%
      \setlength{\topsep}{0pt}% space before/after the list
      \setlength{\partopsep}{0pt}%
      \setlength{\parsep}{0pt}%
      \setlength{\itemsep}{2pt}% space between items
      \renewcommand*{\makelabel}[1]{}% suppress the bullet
  }}%
  {\end{list}}

\newenvironment{innerlist}
  {\begin{list}{}{%
      \setlength{\leftmargin}{-2pt}%
      \setlength{\labelwidth}{0pt}%
      \setlength{\labelsep}{0pt}%
      \setlength{\itemindent}{0pt}%
      \setlength{\topsep}{0pt}% space before/after the list
      \setlength{\partopsep}{0pt}%
      \setlength{\parsep}{0pt}%
      \setlength{\itemsep}{1pt}% space between items
%      \renewcommand*{\makelabel}[1]{\hss\llap{##1\,}}% 
  }}%
  {\end{list}}

\newenvironment{eqlist}
  {\clubpenalty=10000
   \widowpenalty=10000
   \begin{list}{}{%
      \raggedright
      \setlength{\leftmargin}{5pt}% no indentation
      \setlength{\labelwidth}{0pt}%
      \setlength{\labelsep}{0pt}%
      \setlength{\itemindent}{-3mm}%
      \setlength{\topsep}{0pt}% space before/after the list
      \setlength{\partopsep}{0pt}%
      \setlength{\parsep}{0pt}%
      \setlength{\itemsep}{1pt}% space between items
      \renewcommand*{\makelabel}[1]{}% suppress the bullet
  }}%
  {\end{list}}


\newcommand\feature[2]{%
  \colorbox{features background}{\parbox[t]{\hsize}{\raggedright\itshape#1}}&
  \mbox{\vtop{\colorbox{features background}
                  {\parbox[t]{\hsize}{\raggedright\upshape#2}}
        \hrule height 0pt depth 0pt\vspace*{\featurespostspace}%
        }}\\
%  \mbox{\vtop{\colorbox{features background}{\parbox[t]{\hsize}{\raggedright\upshape#2}}}}\\%
}

\newdimen\featurespostspace
\featurespostspace=3pt
\newdimen\featurespostdepth
\featurespostdepth=0pt % likely obsolete
\newcommand\described[2]{#1&#2\vrule width 0pt height 0pt depth \featurespostdepth\relax\\[\featurespostspace]}

\newdimen\featuresnamewidth % space on left for name of a feature
\featuresnamewidth=28mm

\newenvironment{featurestab}
  {\def\arraystretch{1.0}\setlength{\my@xa}{\hsize-\featuresnamewidth-3\tabcolsep}%
   \begin{tabular}{@{}>{\raggedright\arraybackslash\itshape}p{\featuresnamewidth}>{\raggedright\arraybackslash}p{\my@xa}<{\strut}@{}}}
  {\end{tabular}}

\newcommand\spellslevel[2][0]{%
    \ifnum#2=0
       \textsf{CANTRIPS (unlimited)}%
    \else
      \textsf{\vrule width 0pt height 14pt depth 0pt
              LEVEL~#2 SPELLS \ifnum#1>0(\slots{#1} per day)\fi}%
    \fi
}

\newenvironment{attackstab}
  {\renewcommand\arraystretch{1.3}%
   \def\notesheader{\multicolumn6{@{}l}{\vrule width 0pt height 18pt\normalsize\textsf{{NOTES}}}\\}%
   \tabcolsep=0.5\tabcolsep
   \normalsize
   \let\dndkeys=\attackkeys
   \begin{tabular*}{\hsize-6mm}{@{\extracolsep{\fill}}cccccc@{}}
   \multicolumn1{@{}l}{\textsf{NAME}}&
   \textsf{ATTACK}&
   \textsf{DAMAGE}&
   \textsf{TYPE}&
   \textsf{RANGE}&
   \textsf{AMMO}\\
   \midrule
  }
  {\end{tabular*}}


% Declare meaningful coordinate registers
\newdimen\my@N  % North (top) y coordinate
\newdimen\my@E  % East (right) x coordinate
\newdimen\my@W  % West (left) x coordinate
\newdimen\my@S  % South (bottom) y coordinate
\newdimen\my@Cx % Center x coordinate
\newdimen\my@Cy % Center y coordinate

% Other useful registers
\newdimen\my@halfwidth
\newdimen\my@halfheight
\newdimen\my@offset

\newdimen\my@xa  % temps don't conflict with pgf
\newdimen\my@ya
\newdimen\my@xb
\newdimen\my@yb
\newdimen\my@xc
\newdimen\my@yc

%%%%%%%%%%%% shapes


\def\shieldTopScale{0.15}
\def\shieldBottomScale{0.3}

% Here is a {\LaTeX} macro that is meant to draw a shield shape.  I
% started with a kite shape using straight lines to connect
% north-west-south-east, then replaced the straight lines with curves.

\pgfkeys{
  /tikz/shield text fraction/.initial=0.67, % where to put center of text top/bottom
  /tikz/shield text fraction/.default=0.67,
}

\pgfdeclareshape{shield}{
  % Inherit anchors from rectangle
  \inheritsavedanchors[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south west}

  \anchor{ac}{
    \southwest \my@W=\pgf@x \my@S=\pgf@y
    \northeast \my@E=\pgf@x \my@N=\pgf@y
    \pgfpoint{0.5\my@W+0.5\my@E}{0.4\my@S+0.6\my@N}%
  }     

  \anchor{text}{%
    \southwest \my@W=\pgf@x \my@S=\pgf@y
    \northeast \my@E=\pgf@x \my@N=\pgf@y
    \pgfkeysgetvalue{/tikz/shield text fraction}{\@fraction}%
    \expandafter\pgf@ya\@fraction\my@S
    \expandafter\pgf@yb\@fraction\my@N
    \pgfpoint{0.5\my@W+0.5\my@E-0.5\wd\pgfnodeparttextbox}
             {\my@S-\pgf@ya+\pgf@yb+0.5\dp\pgfnodeparttextbox-0.5\ht\pgfnodeparttextbox}%
% XXX consider \pgfpointlineattime
  }

  % Background path (defines the shape outline)
  \backgroundpath{


    % Get the corners
    \southwest \my@W=\pgf@x \my@S=\pgf@y
    \northeast \my@E=\pgf@x \my@N=\pgf@y
    % p + t(q - p) == (1-t)*p + t * q
    \pgfmathsetlength\my@Cx{0.5\my@W+0.5\my@E}
    \pgfmathsetlength\my@Cy{0.2\my@S+0.80\my@N}
    \def\north{\pgfpoint{\my@Cx}{\my@N}}
    \def\west {\pgfpoint{\my@W}{\my@Cy}}
    \def\south{\pgfpoint{\my@Cx}{\my@S}}
    \def\east {\pgfpoint{\my@E}{\my@Cy}}

    % Draw kite shape with curved lines
    \pgfpathmoveto{\north}
    
    % Curve from north to west
    \pgfpointlineattime{0.5}{\west}{\north} % bisector
    \pgfgetlastxy{\my@xa}{\my@ya}
    \pgfpointdiff{\west}{\north}
    \pgfgetlastxy{\my@xb}{\my@yb} % note swap
    \pgfpathquadraticcurveto
        {\pgfpointadd{\pgfpoint{\my@xa}{\my@ya}}
                     {\pgfpointscale{\shieldTopScale}{\pgfpoint{\my@yb}{-\my@xb}}}}
        {\west}
    
    % Curve from west to south
    \pgfpointlineattime{0.5}{\south}{\west} % bisector
    \pgfgetlastxy{\my@xa}{\my@ya}
    \pgfpointdiff{\south}{\west}
    \pgfgetlastxy{\my@xb}{\my@yb} % note swap
    \pgfpathquadraticcurveto
        {\pgfpointadd{\pgfpoint{\my@xa}{\my@ya}}
                     {\pgfpointscale{\shieldBottomScale}{\pgfpoint{-\my@yb}{\my@xb}}}}
        {\south}
    
    % Curve from south to east
    \pgfpointlineattime{0.5}{\east}{\south} % bisector
    \pgfgetlastxy{\my@xa}{\my@ya}
    \pgfpointdiff{\east}{\south}
    \pgfgetlastxy{\my@xb}{\my@yb} % note swap
    \pgfpathquadraticcurveto
        {\pgfpointadd{\pgfpoint{\my@xa}{\my@ya}}
                     {\pgfpointscale{\shieldBottomScale}{\pgfpoint{-\my@yb}{\my@xb}}}}
        {\east}
    
    % Curve from east to north (closing the path)
    \pgfpointlineattime{0.5}{\north}{\east} % bisector
    \pgfgetlastxy{\my@xa}{\my@ya}
    \pgfpointdiff{\north}{\east}
    \pgfgetlastxy{\my@xb}{\my@yb} % note swap
    \pgfpathquadraticcurveto
        {\pgfpointadd{\pgfpoint{\my@xa}{\my@ya}}
                     {\pgfpointscale{\shieldTopScale}{\pgfpoint{\my@yb}{-\my@xb}}}}
        {\north}
  }
}

\tikzset{ 
  inner shield/.style={  % puts a second line inside a shield
    append after command={
        \pgfextra{%
        \pgfpointdiff{\pgfpointanchor{\tikzlastnode}{south west}}{\pgfpointanchor{\tikzlastnode}{north east}}%
        \pgfgetlastxy{\@shieldwidth}{\@shieldheight}%
        }
       (\tikzlastnode) node [shield,minimum width=\@shieldwidth,minimum height=\@shieldheight,draw,thin,scale=0.88,fill=none] {}
    }
  },
  inner circle/.style={  % and inside a circle
    append after command={
        \pgfextra{%
        \typeout{circle last node is \tikzlastnode}%
        \pgfpointdiff{\pgfpointanchor{\tikzlastnode}{west}}{\pgfpointanchor{\tikzlastnode}{east}}%
        \pgfgetlastxy{\@circlewidth}{\@circledummy}%
        \pgfpointdiff{\pgfpointanchor{\tikzlastnode}{south}}{\pgfpointanchor{\tikzlastnode}{north}}%
        \pgfgetlastxy{\@circledummy}{\@circleheight}%
        \typeout{circle width is \@circlewidth}%
        }
       (\tikzlastnode) node [circle,minimum width=\@circlewidth,minimum height=\@circleheight,draw,thin,scale=0.82,fill=none] {}
    }
  },
}



\pgfkeys{
  /tikz/long hexagon angle/.initial=30,
  /tikz/long hexagon angle/.default=30
}




\newcommand\setlonghexoffset[1]{%
    % Get angle and calculate offset
    \pgfmathsetmacro{\hexangle}{\pgfkeysvalueof{/tikz/long hexagon angle}}%
    \pgfmathsetlength{#1}{(0.5\my@N-0.5\my@S)*tan(\hexangle)}%
}


% Macro to set NESW coordinates from southwest/northeast
%   (moves corners inward according to outer sep)
\def\setmy@NEWSC{%
  \pgfpointadd{\southwest}{\pgfpoint{\pgfkeysvalueof{/pgf/outer xsep}}
                                    {\pgfkeysvalueof{/pgf/outer ysep}}}%
  \my@W=\pgf@x%
  \my@S=\pgf@y%
  \pgfpointadd{\northeast}{\pgfpointscale{-1}{\pgfpoint{\pgfkeysvalueof{/pgf/outer xsep}}{\pgfkeysvalueof{/pgf/outer ysep}}}}%
  \my@E=\pgf@x%
  \my@N=\pgf@y%
  % Calculate center
  \my@Cx=.5\my@W%
  \advance\my@Cx by.5\my@E%
  \my@Cy=.5\my@S%
  \advance\my@Cy by.5\my@N%
}

\def\setmy@halves{%
  % Calculate half dimensions
  \my@halfwidth=\my@E%
  \advance\my@halfwidth by-\my@W%
  \my@halfwidth=.5\my@halfwidth%
  \my@halfheight=\my@N%
  \advance\my@halfheight by-\my@S%
  \my@halfheight=.5\my@halfheight%
}

\pgfdeclareshape{long hexagon}{%
  % Inherit anchors from rectangle
  \inheritsavedanchors[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south west}
  
 % Saved anchor for inner north west
  \anchor{inner north west}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@W+\my@offset}{\my@N}% inner NW
  }
  \anchor{inner north east}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@E-\my@offset}{\my@N}% inner NW
  }
  
  \anchor{inner south west}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@W+\my@offset}{\my@S}% inner NW
  }
  \anchor{inner south east}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@E-\my@offset}{\my@S}% inner NW
  }
  
%  \anchor{inner north east}{\pgfprocess{\pgfpointanchor{\tikz@fig@name}{inner north west}}\pgf@x=-\pgf@x}
%  \anchor{inner south west}{\pgfprocess{\pgfpointanchor{\tikz@fig@name}{inner north west}}\pgf@y=-\pgf@y}
%  \anchor{inner south east}{\pgfprocess{\pgfpointanchor{\tikz@fig@name}{inner north west}}\pgf@x=-\pgf@x\pgf@y=-\pgf@y}
  


  % Background path
  \backgroundpath{%
    % Get NESW coordinates
    \setmy@NEWSC
    % Get angle and calculate offset
    \pgfmathsetmacro{\hexangle}{\pgfkeysvalueof{/tikz/long hexagon angle}}%
    \pgfmathsetlength\my@offset{(0.5\my@N-0.5\my@S)*tan(\hexangle)}%
    % Draw hexagon using meaningful coordinates
    \pgfpathmoveto{\pgfpoint{\my@W}{\my@Cy}}% west vertex
    \pgfpathlineto{\pgfpoint{\my@W+\my@offset}{\my@N}}% inner NW
    \pgfpathlineto{\pgfpoint{\my@E-\my@offset}{\my@N}}% inner NE
    \pgfpathlineto{\pgfpoint{\my@E}{\my@Cy}}% east vertex
    \pgfpathlineto{\pgfpoint{\my@E-\my@offset}{\my@S}}% inner SE
    \pgfpathlineto{\pgfpoint{\my@W+\my@offset}{\my@S}}% inner SW
    \pgfpathclose%
  }
}

\pgfkeys{
  /tikz/long octagon angle/.initial=30,
  /tikz/long octagon angle/.default=30,
  /tikz/long octagon end height/.initial=3mm,
  /tikz/long octagon end height/.default=3mm,
}

\pgfdeclareshape{long octagon}{%
  % Inherit anchors from rectangle
  \inheritsavedanchors[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south west}
  
 % Saved anchor for inner north west
  \anchor{inner north west}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@W+\my@offset}{\my@N}% inner NW
  }
  \anchor{inner north east}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@E-\my@offset}{\my@N}% inner NW
  }
  
  \anchor{inner south west}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@W+\my@offset}{\my@S}% inner NW
  }
  \anchor{inner south east}{%
    \setmy@NEWSC
    \setlonghexoffset{\my@offset}%
    \pgfpoint{\my@E-\my@offset}{\my@S}% inner NW
  }
  
%  \anchor{inner north east}{\pgfprocess{\pgfpointanchor{\tikz@fig@name}{inner north west}}\pgf@x=-\pgf@x}
%  \anchor{inner south west}{\pgfprocess{\pgfpointanchor{\tikz@fig@name}{inner north west}}\pgf@y=-\pgf@y}
%  \anchor{inner south east}{\pgfprocess{\pgfpointanchor{\tikz@fig@name}{inner north west}}\pgf@x=-\pgf@x\pgf@y=-\pgf@y}
  


  % Background path
  \backgroundpath{%
    % Get NESW coordinates
    \setmy@NEWSC
    \pgfmathsetmacro{\octangle}{\pgfkeysvalueof{/tikz/long octagon angle}}%
    \pgfmathsetlength{\my@ya}{\pgfkeysvalueof{/tikz/long octagon end height}}%

    % Get angle and calculate offset
    \pgfmathsetlength\my@offset{(0.5\my@N-0.5\my@S-0.5\my@ya)*tan(\octangle)}%
    % Draw octagon using meaningful coordinates
    \pgfpathmoveto{\pgfpoint{\my@W}{\my@Cy+0.5\my@ya}}% west vertex
    \pgfpathlineto{\pgfpoint{\my@W+\my@offset}{\my@N}}% inner NW
    \pgfpathlineto{\pgfpoint{\my@E-\my@offset}{\my@N}}% inner NE
    \pgfpathlineto{\pgfpoint{\my@E}{\my@Cy+0.5\my@ya}}% west vertex
    \pgfpathlineto{\pgfpoint{\my@E}{\my@Cy-0.5\my@ya}}% west vertex
    \pgfpathlineto{\pgfpoint{\my@E-\my@offset}{\my@S}}% inner SE
    \pgfpathlineto{\pgfpoint{\my@W+\my@offset}{\my@S}}% inner SW
    \pgfpathlineto{\pgfpoint{\my@W}{\my@Cy-0.5\my@ya}}% east vertex
    \pgfpathclose%
  }
}


\pgfdeclareshape{decorated long octagon}{%
  % Inherit everything from long octagon
  \inheritsavedanchors[from=long octagon]
  \inheritanchor[from=long octagon]{center}
  \inheritanchor[from=long octagon]{north}
  \inheritanchor[from=long octagon]{south}
  \inheritanchor[from=long octagon]{east}
  \inheritanchor[from=long octagon]{west}
  \inheritanchor[from=long octagon]{north east}
  \inheritanchor[from=long octagon]{north west}
  \inheritanchor[from=long octagon]{south east}
  \inheritanchor[from=long octagon]{south west}
  \inheritbackgroundpath[from=long octagon]
  
  % Add decorations before the background
  \beforebackgroundpath{%
    % Get coordinates and stub radius
    \setmy@NEWSC

    \my@inset=10pt
    \pgfsetlinewidth{0.5pt}%
    \pgfpathrectangle{\pgfpoint{\my@W+\my@inset}{\my@S+\my@inset}}%
                     {\pgfpoint{\my@E-\my@W-2\my@inset}{\my@N-\my@S-2\my@inset}}%
    \pgfusepath{stroke}%
  }
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%    VARIABLES
%

%-----------------------------------------------------------------
% 1. \newDND{<name>}   – declare a key (no value yet)
% 2. \setDND{<name>}{<value>}   – assign a value (must be declared)
% 3. \valueDND{<name>}   – retrieve value (must be set)
%-----------------------------------------------------------------
\newcommand{\newDND}[1]{%
  \@ifundefined{dnd@decl@#1}{%
    \expandafter\def\csname dnd@decl@#1\endcsname{}%  mark as declared
    \expandafter\def\csname dnd@font@#1\endcsname{}%  normally no font change
  }{%
    \PackageError{dnd}{DND key `#1' already declared}{}%
  }%
}

%-----------------------------------------------------------------
%-----------------------------------------------------------------
\newcommand{\setDND}[2]{%
  \@ifundefined{dnd@decl@#1}{%
    \PackageError{dnd}{DND key `#1' has not been declared}%
                   {Declare it first with \string\newDND.}%
  }{%
    \expandafter\def\csname dnd@val@#1\endcsname{#2}%
  }%
}

%-----------------------------------------------------------------
%-----------------------------------------------------------------
\newcommand{\valueDND}[1]{%
  \@ifundefined{dnd@decl@#1}{%
    \PackageError{dnd}{DND key `#1' has not been declared}{}%
  }{%
    \@ifundefined{dnd@val@#1}{%
      \PackageError{dnd}{DND key `#1' has no value yet}%
                     {Assign one with \string\setDND.}%
    }{%
      \csname dnd@val@#1\endcsname
    }%
  }%
}

\newcommand{\useDNDfont}[1]{%
  \@ifundefined{dnd@font@#1}{%
    \PackageError{dnd}{DND key `#1' has not been declared}{}%
  }{%
    \csname dnd@font@#1\endcsname
  }%
}

\WithSuffix\newcommand\useDNDfont*[1]{%
  \@ifundefined{dnd@font@#1}{}{\useDNDfont{#1}}%
}

\newcommand\setDNDlabel[2]{%
  \expandafter\def\csname dnd@label@#1\endcsname{#2}%
}
\newcommand\getDNDlabel[1]{%
  \@ifundefined{dnd@label@#1}{#1}{\csname dnd@label@#1\endcsname}%
}


% 3. Equipment category system
%-----------------------------------------------------------------
% \newDNDitems{FOO}{N} - declare category FOO with weight N per item
% \resetDNDitems - reinitialize all categories
% \addDNDitem[<weight>]{<category>}{<item>} - add item to category

% Storage for declared categories
\newcommand{\@dnditemcategories}{}

% \newDNDitems{FOO}{N} - declare a new equipment category
\newcommand{\newDNDitems}[2]{%
  % Add category to list
  \expandafter\gdef\expandafter\@dnditemcategories\expandafter{\@dnditemcategories,#1}%
  % Create counter for total weight (FOO stones)
  \newcounter{#1 stones}%
  % Define default weight per item (in tenths of stones)
  \expandafter\gdef\csname @dndweight@#1\endcsname{#2}%
  \expandafter\newtoks\csname #1 list\endcsname
}

\newcommand\withitemweight[2]{%
  \@ifundefined{c@#2 stones}{%
    \PackageError{dnd}{DND item type `#2' has not been declared}{}%
  }{%
    #1{\value{#2 stones}}%
  }%
}

% \resetDNDitems - reinitialize all declared categories
\newcommand{\resetDNDitems}{%
  \@for\@category:=\@dnditemcategories\do{%
    \ifx\@category\empty\else
      \setcounter{\@category\space stones}{0}%
      \expandafter\gdef\csname \@category\space list\endcsname{}%
    \fi
  }%
}

\newtoks\@dnditemtoks

% Updated \addDNDitem[<weight>]{<category>}{<item>}
%    adds \DNDitem{item}{weight} to list
\newcommand{\addDNDitem}[3][]{%
  \@ifundefined{c@#2 stones}{%
    \PackageError{dnd}{adding item: DND item type `#2' has not been declared}{}%
  }{%
    % Determine weight to add
    \ifthenelse{\equal{#1}{}}{%
      % Use default weight for category
      \edef\@itemweight{\csname @dndweight@#2\endcsname}%
    }{%
      % Use specified weight
      \edef\@itemweight{#1}%
    }%
    % Add weight to category counter
    \addtocounter{#2 stones}{\@itemweight}%
  \begingroup
  %\tracingmacros=1
  %\tracingcommands=1
    \expandafter\let\expandafter\@thelist\csname#2 list\endcsname
    \edef\@doit{\noexpand\@thelist={\the\@thelist\noexpand\DNDitem{#3}{\@itemweight}}}%
    \global\@doit
  \endgroup
  }
}

\newcommand\doDNDitems[1]{%
  \@ifundefined{#1 list}{%
    \PackageError{dnd}{DND item type `#1' has not been declared}{}%
  }{%
    \expandafter\the\csname#1 list\endcsname
  }%
}

% Declare all equipment categories with their default weights
\newDNDitems{HEAVY WEAPONS}{10}
\newDNDitems{NORMAL WEAPONS}{5}
\newDNDitems{LIGHT WEAPONS}{2}
\newDNDitems{SHIELDS}{5}
\newDNDitems{HEAVY ARMOR}{40}
\newDNDitems{MEDIUM ARMOR}{20}
\newDNDitems{LIGHT ARMOR}{10}
\newDNDitems{HEAVY ITEMS}{10}
\newDNDitems{SLOTTED ITEMS}{2}
\newDNDitems{SMALL ITEMS}{0}
\newDNDitems{STORED ITEMS}{0}

\newcommand{\setDNDfont}[2]{%
  \@ifundefined{dnd@font@#1}{%
    \PackageError{dnd}{DND key `#1' has not been declared}{}%
  }{%
    \expandafter\def\csname dnd@font@#1\endcsname{#2}%
  }%
}

\expandafter\newcommand\csname dnd@font@DEFAULT LABEL\endcsname{}

% ---- labels


%-----------------------------------------------------------------
% 4. \ifDNDdefined{<name>}{<true>}{<false>}
%    Succeeds *only* after a value has been set.
%-----------------------------------------------------------------
\newcommand{\ifDNDdefined}[3]{%
  \@ifundefined{dnd@val@#1}{#3}{#2}%
}

\newcommand{\ifDNDdeclared}[3]{%
  \@ifundefined{dnd@decl@#1}{#3}{#2}%
}

\newcommand{\ifDNDfont}[3]{%
  \@ifundefined{dnd@font@#1}{#3}{#2}%
}

\let\getDND\valueDND
\newcommand{\rawgetDND}[1]{\csname dnd@val@#1\endcsname}


\WithSuffix\newcommand\getDND*[1]{%
  \ifDNDdefined{#1}
    {\getDND{#1}}
    {}%
}

\WithSuffix\newcommand\getDND+[2]{%
  \ifDNDdefined{#1}
    {\getDND{#1}}
    {#2}%
}

\newcommand\ggg{%
  \@ifnextchar*\@gggstar\@gggnone
}
\newcommand\@gggstar[1]{\ifDNDdefined{#1}{\getDND{#1}}{}}
\let\@gggnone\getDND

\newif\ifvalnonempty
\newcommand{\ifDNDnonempty}[3]{%
  \ifDNDdefined{#1}{%
    % Name is defined, now check if it's non-empty
    \expandafter\ifx\expandafter\empty\csname dnd@val@#1\endcsname\empty
%      \typeout{empty #1 is !\csname dnd@val@#1\endcsname!}%
      % Empty (expands to \relax)
      #3%
    \else
%      \typeout{nonempty #1 is !\csname dnd@val@#1\endcsname!}%
      % Non-empty
      #2%
    \fi
  }{%
    % Name is not defined
    #3%
  }%
}

\newcommand\whenDNDnonempty[2]{%
  \ifDNDnonempty{#1}{#2}{}%
}
\newcommand\whenDNDtrue[2]{%
  \ifDNDfalse{#1}{}{#2}%
}
\newcommand\whenDNDfalse[2]{%
  \ifDNDfalse{#1}{#2}{}%
}

%-----------------------------------------------------------------
% 5. \ifDNDfalse{<name>}{<true>}{<false>}
%    Returns true code if variable is false (undefined, empty, "0", or "false")
%-----------------------------------------------------------------
\newcommand{\ifDNDfalse}[3]{%
  \ifDNDdefined{#1}{%
    % Variable is defined, check its value
    \expandafter\let\expandafter\@dnd@variable@value\csname dnd@val@#1\endcsname
    \expandafter\def\expandafter\tempval\expandafter{\@dnd@variable@value}%
    \ifx\tempval\empty
      % Empty string - false
      #2%
    \else
      % Check if value is "0" or "false"
      \def\tempzero{0}%
      \def\tempfalse{false}%
      \ifx\tempval\tempzero
        % Value is "0" - false
        #2%
      \else
        \ifx\tempval\tempfalse
          % Value is "false" - false
          #2%
        \else
          % Value is something else - true
          #3%
        \fi
      \fi
    \fi
  }{%
    % Variable is not defined - false
    #2%
  }%
}



%%  A "stub rectangle" is a rectangle except each
%%  corner is replaced with a corner circle, as if a circular bite had
%%  been taken out of each corner.  Get the radius from a tikz key `stub
%%  radius`, and let it default to 5pt.

\pgfkeys{
  /tikz/stub radius/.initial=5pt,
  /tikz/stub radius/.default=5pt,
  /tikz/stub inset fraction/.initial=0.33333,
  /tikz/stub inset fraction/.default=0.33333,
}

\newdimen\my@stubradius

\pgfdeclareshape{stub rectangle}{%
  % Inherit anchors from rectangle
  \inheritsavedanchors[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{text}
  
  % Background path
  \backgroundpath{%
    % Get NESW coordinates
    \setmy@NEWSC
    \setmy@halves
    % Get stub radius
    \pgfmathsetlength\my@stubradius{\pgfkeysvalueof{/tikz/stub radius}}%
    % Check if stub radius is too large
    \ifdim\my@stubradius>\my@halfwidth
      \pgferror{stub radius (\the\my@stubradius) is larger than half the width (\the\my@halfwidth)}%
    \fi
    \ifdim\my@stubradius>\my@halfheight
      \pgferror{stub radius (\the\my@stubradius) is larger than half the height (\the\my@halfheight)}%
    \fi
    % Draw the path with cut corners
    % Start at bottom edge, after SW corner bite
    \pgfpathmoveto{\pgfpoint{\my@W+\my@stubradius}{\my@S}}%
    % Line to SE corner bite start
    \pgfpathlineto{\pgfpoint{\my@E-\my@stubradius}{\my@S}}%
    % SE corner arc: we're west of corner, need to go north
    % Arc goes counterclockwise from current position
    \pgfpatharc{180}{90}{\my@stubradius}%
    % Now at radius north of SE corner
    % Line to NE corner bite start
    \pgfpathlineto{\pgfpoint{\my@E}{\my@N-\my@stubradius}}%
    % NE corner arc: we're south of corner, need to go west
    \pgfpatharc{270}{180}{\my@stubradius}%
    % Now at radius west of NE corner
    % Line to NW corner bite start
    \pgfpathlineto{\pgfpoint{\my@W+\my@stubradius}{\my@N}}%
    % NW corner arc: we're east of corner, need to go south
    \pgfpatharc{0}{-90}{\my@stubradius}%
    % Now at radius south of NW corner
    % Line to SW corner bite start
    \pgfpathlineto{\pgfpoint{\my@W}{\my@S+\my@stubradius}}%
    % SW corner arc: we're north of corner, need to go east
    \pgfpatharc{90}{0}{\my@stubradius}%
    % Now back at starting point
    \pgfpathclose%
  }
}


\pgfdeclareshape{clipped rectangle}{%
  % Inherit anchors from rectangle
  \inheritsavedanchors[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{text}
  
  % Background path
  \backgroundpath{%
    % Get NESW coordinates
    \setmy@NEWSC
    \setmy@halves
    % Get stub radius
    \pgfmathsetlength\my@stubradius{\pgfkeysvalueof{/tikz/stub radius}}%
    % Check if stub radius is too large
    \ifdim\my@stubradius>\my@halfwidth
      \pgferror{stub radius (\the\my@stubradius) is larger than half the width (\the\my@halfwidth)}%
    \fi
    \ifdim\my@stubradius>\my@halfheight
      \pgferror{stub radius (\the\my@stubradius) is larger than half the height (\the\my@halfheight)}%
    \fi
    % Draw the path with cut corners
    % Start at bottom edge, after SW corner bite
    \pgfpathmoveto{\pgfpoint{\my@W+\my@stubradius}{\my@S}}%
    % Line to SE corner bite start
    \pgfpathlineto{\pgfpoint{\my@E-\my@stubradius}{\my@S}}%
    \pgfpathlineto{\pgfpoint{\my@E}{\my@S+\my@stubradius}}%
    \pgfpathlineto{\pgfpoint{\my@E}{\my@N-\my@stubradius}}%
    \pgfpathlineto{\pgfpoint{\my@E-\my@stubradius}{\my@N}}%
    \pgfpathlineto{\pgfpoint{\my@W+\my@stubradius}{\my@N}}%
    \pgfpathlineto{\pgfpoint{\my@W}{\my@N-\my@stubradius}}%
    \pgfpathlineto{\pgfpoint{\my@W}{\my@S+\my@stubradius}}%
    \pgfpathclose%
  }
}


%% Now I'd like you to define a shape "decorated stub rectangle",
%% which should inherit from "stub rectangle." It should use
%% \beforebackgroundpath to draw the following:
%%
%%  - Inside the bounding box by a distance of one-third the stub
%%    radius, a rectangle "A" drawn with a line thickness of 0.5pt.
%%
%%  - Inside that rectangle "A" by the same distance, along only the east and west edges, a
%%    line drawn with a thickness of 0.3 points.  This line should
%%    extend not the full length of the edge, but a distance 1.5x the
%%    stub radius from both top and bottom.
%%
%%  - Inside each corner of rectangle "A", a quarter circle.



\newdimen\my@inset
\newdimen\my@cornerradius

\newcommand\@ifdrawing[1]{%  tests if draw=none
  \begingroup
  \tikz@mode
  \iftikz@mode@draw\def\x{\endgroup#1}\else\def\x{\endgroup}\fi
  \x
%  \pgfkeysgetvalue{/tikz/draw/.@cmd}{\@drawvalue}%
%  \show\@drawvalue
%  \iftikz@mode@draw
%    #1%
%  \fi
}

\newcommand\@decorate@stub@rectangle{%
      % Get coordinates and stub radius
      \setmy@NEWSC
      \pgfmathsetlength\my@stubradius{\pgfkeysvalueof{/tikz/stub radius}}%
      % Calculate inset (one-third of stub radius)
      \expandafter\my@inset\pgfkeysvalueof{/tikz/stub inset fraction}\my@stubradius
%      \divide\my@inset by 3
      % Calculate corner radius for quarter circles
      \my@cornerradius=\my@inset
      
      % Draw rectangle A (inset by one-third stub radius)
      \pgfsetlinewidth{0.5pt}%
      \pgfpathrectangle{\pgfpoint{\my@W+\my@inset}{\my@S+\my@inset}}%
                       {\pgfpoint{\my@E-\my@W-2\my@inset}{\my@N-\my@S-2\my@inset}}%
      \pgfusepath{stroke}%
      
      % Draw east and west edge lines
      \pgfsetlinewidth{0.3pt}%
      \pgfmathsetlength\my@cornerradius{1.0*\my@stubradius}%
      % West edge line
      \pgfpathmoveto{\pgfpoint{\my@W+2\my@inset}{\my@S+\my@inset+\my@cornerradius}}%
      \pgfpathlineto{\pgfpoint{\my@W+2\my@inset}{\my@N-\my@inset-\my@cornerradius}}%
      % East edge line
      \pgfpathmoveto{\pgfpoint{\my@E-2\my@inset}{\my@S+\my@inset+\my@cornerradius}}%
      \pgfpathlineto{\pgfpoint{\my@E-2\my@inset}{\my@N-\my@inset-\my@cornerradius}}%
      \pgfusepath{stroke}%
      
      % Draw quarter circles in corners of rectangle A
      \pgfsetlinewidth{0.5pt}%
      % SW corner quarter circle
      \pgfpathmoveto{\pgfpoint{\my@W+\my@inset+\my@inset}{\my@S+\my@inset}}%
      \pgfpatharc{0}{90}{\my@inset}%
      \pgfusepath{stroke}%
      % SE corner quarter circle
      \pgfpathmoveto{\pgfpoint{\my@E-\my@inset}{\my@S+\my@inset+\my@inset}}%
      \pgfpatharc{90}{180}{\my@inset}%
      \pgfusepath{stroke}%
      % NE corner quarter circle
      \pgfpathmoveto{\pgfpoint{\my@E-\my@inset-\my@inset}{\my@N-\my@inset}}%
      \pgfpatharc{180}{270}{\my@inset}%
      \pgfusepath{stroke}%
      % NW corner quarter circle
      \pgfpathmoveto{\pgfpoint{\my@W+\my@inset}{\my@N-\my@inset-\my@inset}}%
      \pgfpatharc{270}{360}{\my@inset}%
      \pgfusepath{stroke}%
}


% Now define decorated stub rectangle
\pgfdeclareshape{decorated stub rectangle}{%
  % Inherit everything from stub rectangle
  \inheritsavedanchors[from=stub rectangle]
  \inheritanchor[from=stub rectangle]{center}
  \inheritanchor[from=stub rectangle]{north}
  \inheritanchor[from=stub rectangle]{south}
  \inheritanchor[from=stub rectangle]{east}
  \inheritanchor[from=stub rectangle]{west}
  \inheritanchor[from=stub rectangle]{north east}
  \inheritanchor[from=stub rectangle]{north west}
  \inheritanchor[from=stub rectangle]{south east}
  \inheritanchor[from=stub rectangle]{south west}
  \inheritanchor[from=stub rectangle]{text}
  \inheritbackgroundpath[from=stub rectangle]
  
  % Add decorations before the background
  \beforebackgroundpath{%
    \@ifdrawing\@decorate@stub@rectangle
  }
}

\newcommand\@decorate@clipped@rectangle{%
 \ifx\pgf@up@stroke\pgfutil@empty\else
    % Get coordinates and stub radius
    \setmy@NEWSC
    \pgfmathsetlength\my@stubradius{\pgfkeysvalueof{/tikz/stub radius}}%
    % Calculate inset (one-third of stub radius)
    \my@inset=2\my@stubradius
    %
    %
    % Draw quarter circles in corners of rectangle A
    \pgfsetlinewidth{0.5pt}%
    % NW corner curve
    \begingroup
      \def\NW{%
        \pgfpathmoveto{\pgfpoint{\my@W}{\my@N-\my@inset}}%
        \pgfpathquadraticcurveto
            {\pgfpoint{\my@W+0.25\my@inset}{\my@N-0.25\my@inset}}
            {\pgfpoint{\my@W+\my@inset}{\my@N}}%
      }
      \def\SW{
        \pgfpathmoveto{\pgfpoint{\my@W}{\my@S+\my@inset}}%
        \pgfpathquadraticcurveto
            {\pgfpoint{\my@W+0.25\my@inset}{\my@S+0.25\my@inset}}
            {\pgfpoint{\my@W+\my@inset}{\my@S}}%
      }

      \NW
      \pgfusepath{stroke}%
      \SW
      \pgfusepath{stroke}%
%
%      \def\vertical{%
%         \pgfpathmoveto{\pgfpoint{}{\my@S}}
%         \pgfpathlineto{\pgfpoint{\my@W+0.15\my@inset}{\my@N}}
%      }
%      \pgfintersectionofpaths{\NW}{\vertical}
%      \pgfpointintersectionsolution{1}
%      \typeout{west solution x=\the\pgf@x}
%      \my@ya=\pgf@y  % X coordinate is bogus, dunno why
%      \pgfpathcircle{\pgfpointintersectionsolution{1}\typeout{west circle y=\the\pgf@y}}{2pt}\pgfusepath{stroke}
%      \pgfintersectionofpaths{\SW}{\vertical}
%      \pgfpointintersectionsolution{1}
%      \my@yb=\pgf@y  % X coordinate is bogus, dunno why
%      \typeout{west=\the\my@W, north=\the\my@N, inter=(\the\pgf@x,\the\pgf@y)}
%      \typeout{west:  high y=\the\my@ya, low y=\the\my@yb, south=\the\my@S}
%      \pgfpathmoveto{\pgfpoint{\my@W+0.15\my@inset}{\my@ya}}
%      \pgfpathlineto{\pgfpoint{\my@W+0.15\my@inset}{\my@yb}}
%      \pgfusepath{stroke}%
%      
      % Northeast
      \pgfpathmoveto{\pgfpoint{\my@E}{\my@N-\my@inset}}%
      \pgfpathquadraticcurveto
          {\pgfpoint{\my@E-0.25\my@inset}{\my@N-0.25\my@inset}}
          {\pgfpoint{\my@E-\my@inset}{\my@N}}%
      \pgfusepath{stroke}%

      % Southeast
      \pgfpathmoveto{\pgfpoint{\my@E}{\my@S+\my@inset}}%
      \pgfpathquadraticcurveto
          {\pgfpoint{\my@E-0.25\my@inset}{\my@S+0.25\my@inset}}
          {\pgfpoint{\my@E-\my@inset}{\my@S}}%
      \pgfusepath{stroke}%

      % EW decorations

      \pgfmathsetlength{\my@xa}{\my@E-0.22\my@inset}
      \pgfpathmoveto{\pgfpoint{\my@xa}{\my@N-1.05\my@stubradius}}
      \pgfpathlineto{\pgfpoint{\my@xa}{\my@S+1.05\my@stubradius}}
      \pgfusepath{stroke}%

      \pgfmathsetlength{\my@xa}{\my@W+0.22\my@inset}
      \pgfpathmoveto{\pgfpoint{\my@xa}{\my@N-1.05\my@stubradius}}
      \pgfpathlineto{\pgfpoint{\my@xa}{\my@S+1.05\my@stubradius}}
      \pgfusepath{stroke}%

    \endgroup

  \fi
}

% Now define decorated rectangle
\pgfdeclareshape{decorated clipped rectangle}{%
  % Inherit everything from clipped rectangle
  \inheritsavedanchors[from=clipped rectangle]
  \inheritanchor[from=clipped rectangle]{center}
  \inheritanchor[from=clipped rectangle]{north}
  \inheritanchor[from=clipped rectangle]{south}
  \inheritanchor[from=clipped rectangle]{east}
  \inheritanchor[from=clipped rectangle]{west}
  \inheritanchor[from=clipped rectangle]{north east}
  \inheritanchor[from=clipped rectangle]{north west}
  \inheritanchor[from=clipped rectangle]{south east}
  \inheritanchor[from=clipped rectangle]{south west}
  \inheritanchor[from=clipped rectangle]{text}
  \inheritbackgroundpath[from=clipped rectangle]
  
  % Add decorations before the background
  \beforebackgroundpath{%
     \@ifdrawing\@decorate@clipped@rectangle
  }
}


%-----------------------------------------------------------------------
% Labeled rectangle shape: rectangle with two text parts (text and label)
%-----------------------------------------------------------------------

\newbox\pgfnodepartlabelbox
\newbox\pgfnodepartctextbox

\pgfdeclareshape{labeled rectangle}
{%
  % Declare node parts - PGF will auto-create \pgfnodeparttextbox and \pgfnodepartlabelbox
  \nodeparts{text,label,ctext}%
  % Saved anchor: northeast corner
  \savedanchor\northeast{%
    % Calculate width
    % Take maximum width of the two parts
    \pgf@x=\wd\pgfnodeparttextbox%
    \ifdim\pgf@x<\wd\pgfnodepartlabelbox%
      \pgf@x=\wd\pgfnodepartlabelbox%
    \fi%
    % Add twice inner xsep
    \pgfmathsetlength\pgf@xc{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@x by 2\pgf@xc%
    % Check minimum width
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/minimum width}}%
    \ifdim\pgf@x<\pgf@xb%
      \pgf@x=\pgf@xb%
    \fi%
    % Now calculate right border: 0.5 * max(text_width, label_width) + 0.5 * total_width + outer sep
    \pgf@x=.5\pgf@x%  half the width of the shape
    \advance\pgf@x by.5\wd\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@xa{\pgfkeysvalueof{/pgf/outer xsep}}%
    \advance\pgf@x by\pgf@xa%
    %
    % No need to calculate height
    \pgf@y=\ht\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by \pgf@ya
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@y by \pgf@ya
  }%
  % Saved anchor: southwest corner
  \savedanchor\southwest{%
    % Calculate width (same as northeast)
    \pgf@x=\wd\pgfnodeparttextbox%
    \ifdim\pgf@x<\wd\pgfnodepartlabelbox%
      \pgf@x=\wd\pgfnodepartlabelbox%
    \fi%
    \pgfmathsetlength\pgf@xc{\pgfkeysvalueof{/pgf/inner xsep}}%
    \advance\pgf@x by 2\pgf@xc%
    \pgfmathsetlength\pgf@xb{\pgfkeysvalueof{/pgf/minimum width}}%
    \ifdim\pgf@x<\pgf@xb%
      \pgf@x=\pgf@xb%
    \fi%
    % Calculate left border
    \pgf@x=-.5\pgf@x%
    \pgf@xa=\wd\pgfnodeparttextbox%
    \advance\pgf@x by 0.5\pgf@xa
    \pgfmathsetlength\pgf@xa{\pgfkeysvalueof{/pgf/outer xsep}}%
    \advance\pgf@x by-\pgf@xa%
    % Calculate height (same as northeast)
    \pgf@y=\ht\pgfnodeparttextbox%
    \advance\pgf@y by\dp\pgfnodeparttextbox%
    \advance\pgf@y by\ht\pgfnodepartlabelbox%
    \advance\pgf@y by\dp\pgfnodepartlabelbox%
    \pgfmathsetlength\pgf@yc{\pgfkeysvalueof{/pgf/minimum label sep}}%
    \advance\pgf@y by\pgf@yc%
    \pgfmathsetlength\pgf@yc{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by 2\pgf@yc%
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/minimum height}}%
    \ifdim\pgf@y<\pgf@yb%
      \pgf@y=\pgf@yb%
    \fi%
    % Calculate lower border: label positioned at inner ysep from south
    \pgf@y=-\pgf@y%
    \advance\pgf@y by\ht\pgfnodeparttextbox%
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by \pgf@ya%
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@y by \pgf@ya%
  }%
  %
  % Anchors
  %
  % Center anchor: geometric center of entire shape
  \anchor{center}{
    \pgf@process{\northeast}%
    \pgf@xa=.5\pgf@x%
    \pgf@ya=.5\pgf@y%
    \pgf@process{\southwest}%
    \pgf@x=.5\pgf@x%
    \pgf@y=.5\pgf@y%
    \advance\pgf@x by \pgf@xa%
    \advance\pgf@y by \pgf@ya%
  }%
  % Text anchor: reference point of main text (baseline at left edge)
  \anchor{text}{%
    \pgf@x=0pt%
    \pgf@y=0pt%
  }%
  % Label anchor: reference point of label text (baseline at left edge)
  \saveddimen\labeldy{%
     \pgf@x=\ht\pgfnodepartlabelbox
     \advance\pgf@x by \dp\pgfnodepartlabelbox
  }
  \saveddimen\ctextdy{%
     \pgf@x=\ht\pgfnodepartctextbox
     \advance\pgf@x by \dp\pgfnodepartctextbox
  }
  \anchor{ctext}{%
    \setmy@NEWSC
    \pgf@ya=\my@N
    \advance\pgf@ya by -\my@S  % total height
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@ya by -\pgf@yb
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@ya by -\pgf@yb
    \advance\pgf@ya by -\ctextdy
    \advance\pgf@ya by -\labeldy
    % need some label sep also?
    % \pgf@ya is twice surrounding space
%    \showthe\pgf@ya
    \pgf@x=0.5\my@W
    \advance\pgf@x by 0.5\my@E
    \advance\pgf@x by -0.5\wd\pgfnodepartctextbox
    \pgf@y=\my@N
    \advance\pgf@y by -0.5\pgf@ya
    \advance\pgf@y by -\ht\pgfnodepartctextbox
    % at this point it *is* vertically centered, but it doesn't *look*
    % vertically centered
    \pgf@ya=\labeldy
    \advance\pgf@y by -0.20\pgf@ya % tweak it
  }
  \anchor{labeltop}{%
    \setmy@NEWSC
    \pgf@y=\my@S
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by \pgf@yb
    \pgfmathsetlength\pgf@yb{\pgfkeysvalueof{/pgf/outer ysep}}%
    \advance\pgf@y by \pgf@yb
    \advance\pgf@y by \labeldy
    % need some label sep also?
    % \pgf@ya is twice surrounding space
%    \showthe\pgf@ya
    \pgf@x=0.5\my@W
    \advance\pgf@x by 0.5\my@E
    \advance\pgf@x by -0.5\wd\pgfnodepartctextbox
  }
  \anchor{label}{%
    % Position label at inner ysep from south edge
    \pgf@process\northeast
    \pgf@xa=\pgf@x
    \pgf@process\southwest
    \pgf@x=0.5\pgf@x
    \advance\pgf@x by 0.5\pgf@xa
    \advance\pgf@x by -0.5\wd\pgfnodepartlabelbox
    %
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/inner ysep}}%
    \advance\pgf@y by\pgf@ya%
    \pgfmathsetlength\pgf@ya{\pgfkeysvalueof{/pgf/outer ysep}}% maybe???
    \advance\pgf@y by\pgf@ya%
    \advance\pgf@y by\dp\pgfnodepartlabelbox%
  }%
  % Standard rectangle anchors
  \anchor{north}{
    \pgf@process{\southwest}%
    \pgf@xa=.5\pgf@x%
    \pgf@process{\northeast}%
    \pgf@x=.5\pgf@x%
    \advance\pgf@x by \pgf@xa%
  }%
  \anchor{south}{
    \pgf@process{\northeast}%
    \pgf@xa=.5\pgf@x%
    \pgf@process{\southwest}%
    \pgf@x=.5\pgf@x%
    \advance\pgf@x by \pgf@xa%
  }%
  \anchor{east}{
    \pgf@process{\southwest}%
    \pgf@ya=.5\pgf@y%
    \pgf@process{\northeast}%
    \pgf@y=.5\pgf@y%
    \advance\pgf@y by \pgf@ya%
  }%
  \anchor{west}{
    \pgf@process{\northeast}%
    \pgf@ya=.5\pgf@y%
    \pgf@process{\southwest}%
    \pgf@y=.5\pgf@y%
    \advance\pgf@y by \pgf@ya%
  }%
  \anchor{north east}{\northeast}%
  \anchor{north west}{
    \pgf@process{\northeast}%
    \pgf@ya=\pgf@y%
    \pgf@process{\southwest}%
    \pgf@y=\pgf@ya%
  }%
  \anchor{south east}{
    \pgf@process{\southwest}%
    \pgf@ya=\pgf@y%
    \pgf@process{\northeast}%
    \pgf@y=\pgf@ya%
  }%
  \anchor{south west}{\southwest}%
  \anchor{mid}{
    \pgf@process{\pgf@anchor@labeled@rectangle@center}%
    \pgfmathsetlength\pgf@y{.5ex}%
  }%
  \anchor{base}{
    \pgf@process{\pgf@anchor@labeled@rectangle@center}%
    \pgf@y=0pt%
  }%
  % Background path (simple rectangle)
  \backgroundpath{
    \pgfpathrectanglecorners
    {\pgfpointadd{\southwest}{\pgfpoint{\pgfkeysvalueof{/pgf/outer xsep}}{\pgfkeysvalueof{/pgf/outer ysep}}}}
    {\pgfpointadd{\northeast}{\pgfpointscale{-1}{\pgfpoint{\pgfkeysvalueof{/pgf/outer xsep}}{\pgfkeysvalueof{/pgf/outer ysep}}}}}
  }%
}

\pgfdeclareshape{labeled stub rectangle}{%
  \nodeparts{text,label,ctext}%
  \inheritsavedanchors[from=labeled rectangle]
  \inheritanchor[from=labeled rectangle]{center}
  \inheritanchor[from=labeled rectangle]{north}
  \inheritanchor[from=labeled rectangle]{south}
  \inheritanchor[from=labeled rectangle]{east}
  \inheritanchor[from=labeled rectangle]{west}
  \inheritanchor[from=labeled rectangle]{north east}
  \inheritanchor[from=labeled rectangle]{north west}
  \inheritanchor[from=labeled rectangle]{south east}
  \inheritanchor[from=labeled rectangle]{south west}
  \inheritanchor[from=labeled rectangle]{text}
  \inheritanchor[from=labeled rectangle]{ctext}
  \inheritanchor[from=labeled rectangle]{label}
  \inheritanchor[from=labeled rectangle]{labeltop}
  
  % Background path
  \backgroundpath{%
    % Get NESW coordinates
    \setmy@NEWSC
    \setmy@halves
    % Get stub radius
    \pgfmathsetlength\my@stubradius{\pgfkeysvalueof{/tikz/stub radius}}%
    % Check if stub radius is too large
    \ifdim\my@stubradius>\my@halfwidth
      \pgferror{stub radius (\the\my@stubradius) is larger than half the width (\the\my@halfwidth)}%
    \fi
    \ifdim\my@stubradius>\my@halfheight
      \pgferror{stub radius (\the\my@stubradius) is larger than half the height (\the\my@halfheight)}%
    \fi
    % Draw the path with cut corners
    % Start at bottom edge, after SW corner bite
    \pgfpathmoveto{\pgfpoint{\my@W+\my@stubradius}{\my@S}}%
    % Line to SE corner bite start
    \pgfpathlineto{\pgfpoint{\my@E-\my@stubradius}{\my@S}}%
    % SE corner arc: we're west of corner, need to go north
    % Arc goes counterclockwise from current position
    \pgfpatharc{180}{90}{\my@stubradius}%
    % Now at radius north of SE corner
    % Line to NE corner bite start
    \pgfpathlineto{\pgfpoint{\my@E}{\my@N-\my@stubradius}}%
    % NE corner arc: we're south of corner, need to go west
    \pgfpatharc{270}{180}{\my@stubradius}%
    % Now at radius west of NE corner
    % Line to NW corner bite start
    \pgfpathlineto{\pgfpoint{\my@W+\my@stubradius}{\my@N}}%
    % NW corner arc: we're east of corner, need to go south
    \pgfpatharc{0}{-90}{\my@stubradius}%
    % Now at radius south of NW corner
    % Line to SW corner bite start
    \pgfpathlineto{\pgfpoint{\my@W}{\my@S+\my@stubradius}}%
    % SW corner arc: we're north of corner, need to go east
    \pgfpatharc{90}{0}{\my@stubradius}%
    % Now back at starting point
    \pgfpathclose%
  }
}


\pgfdeclareshape{decorated labeled stub rectangle}{%
  \nodeparts{text,label,ctext}%
  % Inherit everything from labeled stub rectangle
  \inheritsavedanchors[from=labeled stub rectangle]
  \inheritanchor[from=labeled stub rectangle]{center}
  \inheritanchor[from=labeled stub rectangle]{north}
  \inheritanchor[from=labeled stub rectangle]{south}
  \inheritanchor[from=labeled stub rectangle]{east}
  \inheritanchor[from=labeled stub rectangle]{west}
  \inheritanchor[from=labeled stub rectangle]{north east}
  \inheritanchor[from=labeled stub rectangle]{north west}
  \inheritanchor[from=labeled stub rectangle]{south east}
  \inheritanchor[from=labeled stub rectangle]{south west}
  \inheritanchor[from=labeled stub rectangle]{text}
  \inheritanchor[from=labeled stub rectangle]{ctext}
  \inheritanchor[from=labeled stub rectangle]{label}
  \inheritanchor[from=labeled stub rectangle]{labeltop}
  \inheritbackgroundpath[from=labeled stub rectangle]
  
  % Add decorations before the background
  \beforebackgroundpath{%
    \@ifdrawing\@decorate@stub@rectangle
  }
}

\pgfdeclareshape{labeled clipped rectangle}{%
  \nodeparts{text,label,ctext}%
  \inheritsavedanchors[from=labeled rectangle]
  \inheritanchor[from=labeled rectangle]{center}
  \inheritanchor[from=labeled rectangle]{north}
  \inheritanchor[from=labeled rectangle]{south}
  \inheritanchor[from=labeled rectangle]{east}
  \inheritanchor[from=labeled rectangle]{west}
  \inheritanchor[from=labeled rectangle]{north east}
  \inheritanchor[from=labeled rectangle]{north west}
  \inheritanchor[from=labeled rectangle]{south east}
  \inheritanchor[from=labeled rectangle]{south west}
  \inheritanchor[from=labeled rectangle]{text}
  \inheritanchor[from=labeled rectangle]{ctext}
  \inheritanchor[from=labeled rectangle]{label}
  \inheritanchor[from=labeled rectangle]{labeltop}
  
  % Background path
  \backgroundpath{%
    % Get NESW coordinates
    \setmy@NEWSC
    \setmy@halves
    % Get stub radius
    \pgfmathsetlength\my@stubradius{\pgfkeysvalueof{/tikz/stub radius}}%
    % Check if stub radius is too large
    \ifdim\my@stubradius>\my@halfwidth
      \pgferror{stub radius (\the\my@stubradius) is larger than half the width (\the\my@halfwidth)}%
    \fi
    \ifdim\my@stubradius>\my@halfheight
      \pgferror{stub radius (\the\my@stubradius) is larger than half the height (\the\my@halfheight)}%
    \fi
    % Draw the path with cut corners
    % Start at bottom edge, after SW corner bite
    \pgfpathmoveto{\pgfpoint{\my@W+\my@stubradius}{\my@S}}%
    % Line to SE corner bite start
    \pgfpathlineto{\pgfpoint{\my@E-\my@stubradius}{\my@S}}%
    \pgfpathlineto{\pgfpoint{\my@E}{\my@S+\my@stubradius}}%
    \pgfpathlineto{\pgfpoint{\my@E}{\my@N-\my@stubradius}}%
    \pgfpathlineto{\pgfpoint{\my@E-\my@stubradius}{\my@N}}%
    \pgfpathlineto{\pgfpoint{\my@W+\my@stubradius}{\my@N}}%
    \pgfpathlineto{\pgfpoint{\my@W}{\my@N-\my@stubradius}}%
    \pgfpathlineto{\pgfpoint{\my@W}{\my@S+\my@stubradius}}%
    \pgfpathclose%
  }
}

\pgfdeclareshape{decorated labeled clipped rectangle}{%
  \nodeparts{text,label,ctext}
  \inheritsavedanchors[from=labeled clipped rectangle]
  \inheritanchor[from=labeled clipped rectangle]{center}
  \inheritanchor[from=labeled clipped rectangle]{north}
  \inheritanchor[from=labeled clipped rectangle]{south}
  \inheritanchor[from=labeled clipped rectangle]{east}
  \inheritanchor[from=labeled clipped rectangle]{west}
  \inheritanchor[from=labeled clipped rectangle]{north east}
  \inheritanchor[from=labeled clipped rectangle]{north west}
  \inheritanchor[from=labeled clipped rectangle]{south east}
  \inheritanchor[from=labeled clipped rectangle]{south west}
  \inheritanchor[from=labeled clipped rectangle]{text}
  \inheritanchor[from=labeled clipped rectangle]{ctext}
  \inheritanchor[from=labeled clipped rectangle]{label}
  \inheritanchor[from=labeled clipped rectangle]{labeltop}
  \inheritbackgroundpath[from=labeled clipped rectangle]
  
  % Add decorations before the background
  \beforebackgroundpath{%
     \@ifdrawing\@decorate@clipped@rectangle
  }
}


\pgfkeys{
  /runwidth/.cd,
  width/.code={
    \expandafter\@runwidth@macro\expandafter{#1}%
  },
  .unknown/.code={} % ignore everything else
}%


\newcommand{\runwidth}[2]{%
  % Store the macro name
  \def\@runwidth@macro{#1}%
  % Set up a key handler for "width"
  % Now parse the key-value list
  \pgfkeys{/runwidth/.cd, #2}%
}

\newcommand\pplabel{{\tiny PASSIVE PERCEPTION}}


\newcommand\tinystacklabel[2]{%
   \raisebox{3mm}{\tiny\begin{tabular}{c}#1\\#2\end{tabular}}}



\newcounter{proficiency bonus}
\newcounter{ptemp}

\newcommand\signed[1]{%
  \setcounter{ptemp}{#1}%
  \expandafter\ifnum\value{ptemp}<0
    \setcounter{ptemp}{0-\value{ptemp}}%
    \textminus\arabic{ptemp}%
  \else
    +\arabic{ptemp}%
  \fi
}

\newif\ifdndstatshield
\dndstatshieldtrue

\DeclareOption{nostatshield}{\dndstatshieldfalse}

\newdimen\savingshieldwidth
\savingshieldwidth=6mm

\newcommand\fullstatbox[5][]{% location name number modifier saving-throw
  \node [statbox,#1] (#2) {\Large \textsf{\signed{#4}}} ;
  \dndtoplabel{#2}{\tiny#2}
  \node[draw,ellipse,ultra thick,width=12mm, height=8mm, fill=stats] at (#2.south) {\textsf{#3}};
  \ifdndstatshield
    \node[draw,shield,shield text fraction=0.55,
          anchor=north,ultra thick,width=\savingshieldwidth, height=10mm, fill=stats,
         ] 
              at ($(#2.north east)+(0.1mm,3mm)$) {\small\textsf{\signed{#5}}};
  \fi
}

\newcommand\blankstatbox[3][]{% location name saving-throw
  \node [statbox,#1] (#2) {} ;
  \dndtoplabel{#2}{\tiny#2}
  \node[draw,ellipse,ultra thick,width=12mm, height=8mm, fill=stats] at (#2.south) {};
  \node[draw,shield,anchor=north,ultra thick,width=6mm, height=10mm, fill=stats] 
            at ($(#2.north east)+(0.1mm,3mm)$) {\raisebox{4pt}{\small{#3}}};
}


\newcommand\dndtoplabel[2]{% {node}{label text}
  \node [outer sep=0pt, inner sep=0pt, below=of #1.north]
        {\textsf{\footnotesize #2}};
}

\newcounter{modifier}
\newcommand\modifier[1]{%
  \pgfmathsetcounter{modifier}{floor((#1 - 10) / 2)}%
  \arabic{modifier}}



\newcounter{statmod}%
\newcounter{saving}%
\newcounter{statnumber}
\newcommand\setstatnumber[1]{\setcounter{statnumber}{#1}}

\newcommand\@themodifier[1]{%
  \pgfmathsetcounter{statmod}{floor((#1 - 10) / 2)}%
  \expandafter\ifnum\value{statmod}<0
     \setcounter{statmod}{0-\value{statmod}}%
     \textminus\arabic{statmod}%
  \else
     +\arabic{statmod}%
  \fi
}
\newcommand\dndmodifier[1]{% 
  \ifDNDdefined{#1}{%
    \expandafter\@themodifier\expandafter{\rawgetDND{#1}}%
  }{}%
}
\newcommand\@thesavingthrow[2]{%
  \pgfmathsetcounter{statmod}{floor((#1 - 10) / 2)}%
  \addtocounter{statmod}{#2}%
  \expandafter\ifnum\value{statmod}<0
     \setcounter{statmod}{0-\value{statmod}}%
     \textminus\arabic{statmod}%
  \else
     +\arabic{statmod}%
  \fi
}

\newcommand\dndsavingthrow[1]{% 
  \begingroup
    \ifDNDdefined{#1}{%
      \ifDNDnonempty{#1 SAVING}{%
          \edef\thing{\value{proficiency bonus}}%
      }{%
          \def\thing{0}%
      }%
      \expandafter\@thesavingthrow\expandafter{\rawgetDND{#1}}{\thing}%
    }{}%
  \endgroup
}
  

\newcommand\statcommon[3]{% name value amount-to-add-to-saving
%   \show\nextstatloc
   \expandafter\setstatnumber\expandafter{#2}%
   % calc package rounds toward zero; do not use
   \pgfmathsetcounter{statmod}{floor((\value{statnumber} - 10) / 2)}%
   \setcounter{saving}{\value{statmod} + #3}%
   \expandafter\fullstatbox\expandafter[\nextstatloc]{#1}{#2}{\thestatmod}{\thesaving}%
   \gdef\nextstatloc{below=7mm of #1}%
}

\newcommand{\stat}[2]{%
   \statcommon{#1}{#2}{0}%
}

\WithSuffix\newcommand\stat*[2]{%
  \statcommon{#1}{#2}{\value{proficiency bonus}}%
}

\newcommand\blankstat[2]{% label, short name
    \expandafter\blankstatbox\expandafter[\nextstatloc]{#1}%
             {\ifDNDnonempty{#2 SAVING}{*}{}}%
    \gdef\nextstatloc{below=7mm of #1}%
}

\newcommand\fullcoinbox[4][]{% location-setter nodename label number
  \node (preliminary #2) [coin,#1,fill=equipment] {#4};
  \node [dndbox,long octagon,long octagon end height=1.5mm,long
         octagon angle=45,fill=equipment, height=5mm, width=13mm,anchor=center]
     at ($(preliminary #2.west)+(0pt,0pt)$)
     {\hbox to 10mm{\hspace*{0mm}\small#3\hss}}
     ;
  \node (#2) [coin,#1,fill=equipment] {#4};
}

\newcommand\nextcoinloc{anchor=north west,at=(coin top left)}

\newcommand\coin[3]{% name label number
   \expandafter\fullcoinbox\expandafter[\nextcoinloc]{#1}{#2}{#3}%
   \gdef\nextcoinloc{below=of #1}%
}

\newDND{AGE}
\newDND{ALIGNMENT}
\newDND{ARMOR CLASS}
\newDND{ATTACKS}
\newDND{BACKGROUND}
\newDND{CHA}
\newDND{CHA SAVING}
\newDND{COLOR}
\newDND{CHARACTER NAME}
\newDND{CLASS + LEVEL}
\newDND{CLASS}
\newDND{CON}
\newDND{CON SAVING}
\newDND{CP}
\newDND{CURRENT HIT POINTS}
\newDND{DESCRIPTION}
\newDND{DEX}
\newDND{DEX SAVING}
\newDND{EP}
\newDND{EQUIPMENT}
\newDND{EQUIPMENT COLS}
\setDND{EQUIPMENT COLS}{2} % default
\newDND{EXPERIENCE POINTS}
\newDND{FEATURES}
\newDND{GM NOTES}
\newDND{GP}
\newDND{HIT DICE}
\newDND{INITIATIVE}
\newDND{INT}
\newDND{INT SAVING}
\newDND{LAYOUT}
\newDND{LEVEL}
\newDND{MAGIC}
\newDND{MAIN PROFICIENCIES}
\newDND{MAX HP}
\newDND{MOTIVATION}
\newDND{OTHER PROFICIENCIES}
\newDND{PASSIVE PERCEPTION}
\newDND{PLAYER NAME}
\newDND{PP}
\newDND{PREGENERATED}
\newDND{PROFICIENCIES} % see also main and other
\newDND{PROFICIENCY BONUS}
\newDND{RACE}
\newDND{SENSES}
\newDND{SHEET ORIGIN}
\newDND{SORCERY POINTS}
\newDND{SP}
\newDND{SPECIALTY}
\newDND{SPEED}
\newDND{SPELL DC}
\newDND{SPELL ATTACK MODIFIER}
\newDND{SPELLCASTING ABILITY MODIFIER}
\newDND{SPELLS KNOWN}
\newDND{STONES} % include page of stuff by stones 
\newDND{SUGGESTED MOTIVATIONS}
\newDND{SUGGESTED NAMES}
\newDND{DOMAIN SPELLS}
\newDND{STR}
\newDND{STR SAVING}
\newDND{VALIDATION ERRORS}
\newDND{WIS}
\newDND{WIS SAVING}

\setDNDfont{PASSIVE PERCEPTION}{\tiny}
\setDNDfont{SORCERY POINTS}{\tiny}
\setDNDfont{DEFAULT LABEL}{\footnotesize} % XXX not used
\setDND{COLOR}{true}

\newcommand\satk{%  Add to user documentation
  \ifDNDnonempty{SPELL ATTACK MODIFIER}%
    {~\getDND{SPELL ATTACK MODIFIER}}%
    {}%
}

\newcommand\spelldc{%
  \ifDNDdefined{SPELL DC}{DC~\getDND*{SPELL DC}}{}%
}

\newcommand\psam{%  Add to user documentation
  \ifDNDnonempty{SPELLCASTING ABILITY MODIFIER}%
    {\expandafter\ifnum\rawgetDND{SPELLCASTING ABILITY MODIFIER}>0
       \expandafter\signed\expandafter{\rawgetDND{SPELLCASTING ABILITY MODIFIER}}%
     \fi
    }
    {+?}%
}

\newcounter{dcresult}

\newcommand\@statdc[1]{% ability-score
    \setcounter{statnumber}{#1}%
    \pgfmathsetcounter{statmod}{floor((\value{statnumber} - 10) / 2)}%
    % Calculate DC: 8 + proficiency bonus + ability modifier
    \setcounter{dcresult}{8 + \value{proficiency bonus} + \value{statmod}}%
    DC~\arabic{dcresult}%
}

\newcommand\statdc[1]{%
  \ifDNDdefined{#1}{%
   \@expandArg\@statdc{\rawgetDND{#1}}%
   % Get the ability score value and calculate modifier
  }{%
    DC~?%
  }%
}


\newcommand\odndstat[2]{% label, short name
  \ifDNDdefined{#2}{%
    \ifDNDdefined{#2 SAVING}%
       {\stat*{#1}{\rawgetDND{#2}}}
       {\stat{#1}{\rawgetDND{#2}}}
  }{%
    \blankstatbox{#1}{#2}{\ifDNDdefined{#2 SAVING}{*}{}}%
  }
}

\newcommand\dndstat[2]{% label, short name
  \ifDNDnonempty{#2}{%
    \ifDNDdefined{#2 SAVING}%
       {\stat*{#1}{\rawgetDND{#2}}}
       {\stat{#1}{\rawgetDND{#2}}}
  }{%
    \blankstat{#1}{#2}%
  }
}


\pgfkeys{
  /attacks/.cd,
  NAME/.code={%
    \gdef\@attackname{#1}%
  },
  ATTACK/.code={%
%    {\def\statdc{\protect\statdc}\typeout{attack #1}}%
    \gdef\@attackattack{#1}%
  },
  DAMAGE/.code={%
%   \typeout{attack damage #1}%
    \gdef\@attackdamage{#1}%
  },
  TYPE/.code={%
    \gdef\@attacktype{#1}%
  },
  RANGE/.code={%
    \gdef\@attackrange{#1}%
  },
  AMMO TYPE/.code={%
    \gdef\@attackammotype{#1}%
  },
  AMMO COUNT/.code={%
    \gdef\@attackammocount{#1}%
  },
  NOTES/.code={%
    \gdef\@attacknotes{#1}%
  },
  .unknown/.code={} % ignore everything else
}%


\newcommand\countfield[1]{% count
  \setbox0\hbox{\large~99~}%
  \@ammowidth=\wd0
  \hbox to \@ammowidth{\hskip0.7pt
                        \rlap{\vrule width \@ammowidth height -2pt depth 2.2pt}%
                       \hss {\color{attacks!70!black}\large#1}\hss}%
}

\newdimen\@ammowidth
\newcommand\ammofield[2]{% amount type
  (\countfield{#1}~#2)%
}


\newcommand\@ammocolumn{%
  \ifx\@attackammotype\empty
     ---
  \else
     \ammofield\@attackammocount\@attackammotype
  \fi
}
\newcommand\attackkeys[1]{%
  \gdef\@attackname{}%
  \gdef\@attackattack{}%
  \gdef\@attackdamage{}%
  \gdef\@attacktype{}%
  \gdef\@attackrange{}%
  \gdef\@attackammotype{}%
  \gdef\@attackammocount{}%
%  {\def\statdc{\protect\statdc}\typeout{attack keys: #1}}%
  \pgfkeys{/attacks/.cd, #1}%
  \@attackname&\@attackattack&\@attackdamage&\@attacktype&\@attackrange&
    \@ammocolumn\\
}


\newcommand\attacknote[2]{%
  \multicolumn6{@{}p{\hsize-10mm}}{#1: \textit{#2}}\\
}

\newcommand\profskip{\medskip}

\newcommand\weaponname[1]{#1} % styles can override


\newcommand\writesplash[3][]{% [annotations] width dndkey
  \node (#3)
     [fill=none,anchor=base west,width=#2,#1] 
    {\hbox to #2{\namestrut\itshape  \getDND*{#3}\hfill}}
   ;
}



% Test a list of names names and assign first two non-empty to specified variables with labels
\newcommand{\firsttwoDNDdefined}[5]{%
  % \label \contents \label \contents {key,key,...,key}
  \def#1{}%
  \def#2{}%
  \def#3{}%
  \def#4{}%
  \foreach \key in {#5}{%
     \expandafter\ifDNDdefined\expandafter{\key}%
         {\ifx#1\empty
            \xdef#1{\key}%
            \edef\defined@go{\noexpand\rawgetDND{\key}}%
            \xdef#2{\defined@go}%
          \else
            \ifx#3\empty
              \xdef#3{\key}%
              \edef\defined@go{\noexpand\rawgetDND{\key}}%
              \xdef#4{\defined@go}%
            \fi
          \fi
         }%
         {}%
   }%
}

\newcommand{\firsttwoDNDnonempty}[5]{%
  % \label \contents \label \contents {key,key,...,key}
  \def#1{}%
  \def#2{}%
  \def#3{}%
  \def#4{}%
  \foreach \key in {#5}{%
     \expandafter\ifDNDnonempty\expandafter{\key}%
         {\ifx#1\empty
            \xdef#1{\key}%
            \edef\defined@go{\noexpand\rawgetDND{\key}}%
            \xdef#2{\defined@go}%
          \else
            \ifx#3\empty
              \xdef#3{\key}%
              \edef\defined@go{\noexpand\rawgetDND{\key}}%
              \xdef#4{\defined@go}%
            \fi
          \fi
         }%
         {}%
   }%
}



\long\def\SplitAtProfskip#1{%
  \SplitAtProfskip@i#1\profskip\@nil
}
\long\def\SplitAtProfskip@i#1\profskip#2\@nil{%
  \def\prof@before{#1}% before part
  \def\prof@after{#2}%  after part (empty if no \profskip in input)
}
\long\def\profskipCar#1{%
  \SplitAtProfskip@i#1\profskip\@nil
  \prof@before
}
\long\def\profskipCdr#1{%
  \SplitAtProfskip@i#1\profskip\@nil
  \prof@after
}
\newcommand*\SplitAtProfskipTwice[1]{%
  \edef\prof@tmp{%
    \noexpand\SplitAtProfskip
    % Two-step expansion of #1, then freeze the result with \unexpanded{...}
    \unexpanded{#1}%
  }%
  \prof@tmp
}

%
% Genius expansion trick
%
% https://tex.stackexchange.com/a/133768/5847

\newcommand\@expandArg[2]{\expandafter\@applyExpanded\expandafter{#2}{#1}}
\newcommand\@applyExpanded[2]{#2{#1}}




%-----------------------------------------------------------------------
% Ranges list environment and \DNDranges macro
%-----------------------------------------------------------------------

% Environment for displaying ranged attack ranges
\newenvironment{rangetable}
  {\par\smallskip\noindent
   \begin{tabular}{@{}l@{ }r@{: }l@{ }l@{}}}
  {\end{tabular}\par}

\newcommand\rangetableline[4]{%
  #1&range&#2 
      &
  \def\@attackammotype{#4}%
  \ifx\@attackammotype\empty\else\ammofield{#3}{#4}\fi
  \\[3pt]
}
\newenvironment{rangeparagraphs}{\raggedright}{}

\newcommand\rangeparagraph[4]{%
  \smallskip
  #1 range: #2%
  \def\@attackammotype{#4}%
  \ifx\@attackammotype\empty\else\ \ammofield{#3}{#4}\fi
  \par
}
\newif\if@ranged@attack
\newif\if@has@ranged@attack

\newcommand\@addrangerendering[5]{% macro name range ammo-count ammo-type
  \g@addto@macro\@rangedlist{#1{#2}{#3}{#4}{#5}}%
}

% Main macro to display ranged attacks
\newcommand{\DNDranges}[2]{% environment-name line-macro
  \ifDNDdefined{ATTACKS}{%
    % Initialize with empty list
    \def\@rangedlist{}%
    \@has@ranged@attackfalse
    % Process attacks using edef approach
    \def\collectrangedattack##1{%
      % Reset values for this attack
      \gdef\@attackname{}%
      \gdef\@attackrange{}%
      \gdef\@attackammotype{}%
      \gdef\@attackammocount{}%
      % Process attack keys
      \pgfkeys{/attacks/.cd, ##1}%
      \@ranged@attacktrue
      \foreach \a in {,5 ft.,5 ft,5 ft,5 ft.,5ft,5ft.,\ditto,---}%
         {\ifx\@attackrange\a\global\@ranged@attackfalse \fi}%
      % Check if range qualifies as ranged attack
      \if@ranged@attack
        \@has@ranged@attacktrue
        \@expandArg
           {\@expandArg
              {\@expandArg
                  {\@expandArg
                     {\@addrangerendering{#2}}%
                   \@attackname}\@attackrange}\@attackammocount}\@attackammotype
       \fi
    }%
    % Temporarily replace dndkeys to use our collector
    \let\@original@dndkeys\dndkeys
    \let\dndkeys\collectrangedattack
    % Process all attacks
    \valueDND{ATTACKS}%
    % Restore original dndkeys
    \let\dndkeys\@original@dndkeys
    % Only emit environment if we have ranged attacks
    \if@has@ranged@attack
      \begin{#1}
      \@rangedlist
      \end{#1}
    \fi
  }{}%
}

\newif\if@has@noted@attack

\newcommand{\DNDattacknotes}{%
  \ifDNDdefined{ATTACKS}{%
    % Initialize with empty list
    \def\@notedlist{}%
    \@has@noted@attackfalse
    % Process attacks using edef approach
    \def\collectnotedattack##1{%
      % Reset values for this attack
      \gdef\@attackname{}%
      \gdef\@attacknotes{}%
      % Process attack keys
      \pgfkeys{/attacks/.cd, ##1}%
      \ifx\@attacknotes\empty
      \else
        \@has@noted@attacktrue
        \@expandArg{\@expandArg\@addattacknotes\@attackname}\@attacknotes
%        \show\@notedlist
      \fi
    }%
    % Temporarily replace dndkeys to use our collector
    \let\@original@dndkeys\dndkeys
    \let\dndkeys\collectnotedattack
    % Process all attacks
    \valueDND{ATTACKS}%
    % Restore original dndkeys
    \let\dndkeys\@original@dndkeys
    % Only emit environment if we have noted attacks
    \if@has@noted@attack
      \begin{attacknotes}
      \@notedlist
      \end{attacknotes}
    \fi
  }{}%
}


\newenvironment{attacknotes}
  {\par\smallskip\noindent
   \tabularx{\hsize}{@{}l@{ }>{\raggedright\arraybackslash\itshape}X@{}}  
  }
  {\endtabularx\par}

\newcommand\@addattacknotes[2]{%
  \g@addto@macro\@notedlist{\attacknote{#1}{#2}}%
}



%%% tikz point delta calculations

\newcommand{\pgfpointtikz}[1]{%
  \tikz@scan@one@point\pgfutil@firstofone(#1)\relax
   % sets \pgf@x and \pgf@y
}
\newcommand\setdeltay[3]{%  #1 := #2.y - #3.y
  \pgfpointtikz{#2}%
  #1=\pgf@y
  \pgfpointtikz{#3}%
  \advance#1 by -\pgf@y
}
%%%%    

\newcommand\setdeltax[3]{%
  \pgfpointtikz{#2}%
  #1=\pgf@x
  \pgfpointtikz{#3}%
  \advance#1 by -\pgf@x
}

\newdimen\sectionheight
\newdimen\sectionwidth

\newdimen\tmpheight
\newdimen\tmpwidth




%%%% parameter through nodes or dummy nodes
\newcommand\@getproperty[1]{%
  \let\@thegetmacro#1%
  \@applygetmacro
}
\newcommand\@applygetmacro[1][]{%
  \@ifmtarg{#1}%
    {\@thegetmacro}% node name is coming
    {\node [#1,draw=none,fill=none] (dummy #1) {}; \@thegetmacro{dummy #1}}%
}

\newcommand\@setproperty[2]{% {\settingmacro}{\destination dimen}
  \let\@thesetmacro#1%
  \let\@thesetdest#2%
  \@applysetmacro
}
\newcommand\@applysetmacro[1][]{%
  \@ifmtarg{#1}%
    {\expandafter\@thesetmacro\@thesetdest}% node name is coming
    {\node [#1,draw=none,fill=none] (dummy #1) {};
     \expandafter\@thesetmacro\@thesetdest{dummy #1}}%
}

\newcommand\@setnodeheight[2]{\setdeltay#1{#2.north}{#2.south}}
\newcommand\setnodeheight{\@setproperty\@setnodeheight}



\newcommand\@setnodewidth[2]{\setdeltax#1{#2.east}{#2.west}}
\newcommand\setnodewidth{\@setproperty\@setnodewidth}

\newdimen\@proptmp
\newcommand\@settextwidth[2]{%
   \@setnodewidth{#1}{#2}%
   \setdeltax\@proptmp{#2.text}{#2.west}%
   \advance#1 by -2\@proptmp
}
\newcommand\settextwidth{\@setproperty\@settextwidth}


\newcommand\ditto{\texttt{"}}




% Provide defaults or handle unknown options if you want
\DeclareOption*{%
  \PackageWarning{mystuff}{Unknown option `\CurrentOption'}%
}

% Actually process all options
\ProcessOptions\relax
