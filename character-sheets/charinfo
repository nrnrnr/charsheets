#!/usr/bin/env lua5.1
--------------------------------------------------------------------------
-- yaml-to-dndtex.lua   ‒  Convert character-sheet YAML to LaTeX macros
-- Usage:   lua yaml-to-dndtex.lua  file.yaml   > file.tex
--          cat file.yaml | lua yaml-to-dndtex.lua   > file.tex
--------------------------------------------------------------------------

------------------ classic print functions ---------------------
local stringf = string.format
local function printf(...) return io.stdout:write(stringf(...)) end
local function eprintf(...) return io.stderr:write(stringf(...)) end
local function fprintf(fd, ...) return fd:write(stringf(...)) end
local function dief(...) eprintf(...); os.exit(1) end
local function errorf(...) return error(stringf(...)) end
local function runf(...) return os.execute(stringf(...)) end
local function outf(out, ...)
  table.insert(out, stringf(...))
  return out
end
----------------------------------------------------------------

local fields = require 'flags'.parser()
  :bool('standalone as s'):help('emit just definitions, not full file')
  :output_file('output as o'):help('where to write if not stdout')
  :string('type as t', 'silverpine'):help('template for character sheet')
  :bool('verbose as v')
  :string('templates', '/home/nr/etc/dnd/resources/character-sheets')
         :help('directory where character-sheet templates live') 
  :minarg(1)
  :parse(arg)

local vprintf = fields.verbose and eprintf or function() end


local function nonempty(v)
  return type(v) == 'number' or type(v) == 'string' and v:find '%S'
end

local lyaml  = require "lyaml"

-- -----------------------------------------------------------------------
-- 0.  Make sure we have a load_all() helper
-- -----------------------------------------------------------------------
local yaml_load_all
if lyaml.load_all then
  yaml_load_all = lyaml.load_all          -- native API present
else
  -- Fallback: wrap single-document loader so we still return a list
  yaml_load_all = function(str)
    local ok, doc = pcall(lyaml.load, str)
    if not ok then
      error("lyaml.load failed: "..tostring(doc))
    end
    return { doc }
  end
end

---------------------------------------------------------------------------
-- 1. TeX-escaping utility
---------------------------------------------------------------------------
local tex_escape_map = {
--  ["\\"] = [[\textbackslash{}]],
  [' '] = '~',
  ["&"]  = [[\&]],
  ["%"]  = [[\%]],
  ["$"]  = [[\$]],
  ["#"]  = [[\#]],
  ["_"]  = [[\_]],
--  ["{"]  = [[\{]],
--  ["}"]  = [[\}]],
  ["~"]  = [[\textasciitilde{}]],
  ["^"]  = [[\textasciicircum{}]],
}

local minustab = { ['-'] = [[\textminus]] }

local function escape (s)
  return (tostring(s):gsub("[\\&%%$#_{}~^]", tex_escape_map)
                     :gsub('([%s%d])%-(%d)', [[%1\textminus%2]])
                     :gsub("−", [[\textminus{}]])
  )
end

local player_template = [[
\player{%
  name={CLASS{} CHARNAME{} (RACE)},
  spelldc={SPELL_DC},
  passivep={PASSIVE_PERCEPTION},
  description={DESCRIPTION},
  stats={STATS},
  proficiencies={THEPROFICIENCIES},
  other={DMFEATURES{}THEMOTIVATION}
}
]]

local saving_throw_proficiencies = {
  Barbarian = { "Strength", "Constitution" },
  Bard      = { "Dexterity", "Charisma" },
  Cleric    = { "Wisdom", "Charisma" },
  Druid     = { "Intelligence", "Wisdom" },
  Fighter   = { "Strength", "Constitution" },
  Monk      = { "Strength", "Dexterity" },
  Paladin   = { "Wisdom", "Charisma" },
  Ranger    = { "Strength", "Dexterity" },
  Rogue     = { "Dexterity", "Intelligence" },
  Sorcerer  = { "Constitution", "Charisma" },
  Warlock   = { "Wisdom", "Charisma" },
  Wizard    = { "Intelligence", "Wisdom" }
}


local function modifier(stat)
  return math.floor((tonumber(stat)-10) / 2.0)
end


local statsstrings = 'STR DEX CON INT WIS CHA'

local function mkstats(doc)
  local saves = { }
  for stat in statsstrings:gmatch '%u+' do
    saves[stat] = ''
  end
  for _, stat in ipairs(saving_throw_proficiencies[doc.CLASS]) do
    saves[stat:sub(1,3):upper()] = [[\*]]
  end
  local stats = { [[\stats]] }
  for stat in statsstrings:gmatch '%u+' do
    table.insert(stats, stringf('{%+d%s}', modifier(assert(doc[stat])), saves[stat]))
  end
  return table.concat(stats, '')
end
                                
  

local function mkplayer(doc)
  doc.CLASS = doc.CLASS or doc['CLASS AND LEVEL']:match '%a+'
  doc.LEVEL = doc.LEVEL or doc['CLASS AND LEVEL']:match '%d+'
  local prof = doc["PROFICIENCY BONUS"] or doc["Proficiency Bonus"]
  if nonempty(doc['CHARACTER NAME']) then
    doc.CHARNAME = doc.CHARNAME or doc['CHARACTER NAME']
  else
    doc.CHARNAME = doc.CHARNAME or [[\]] .. doc.CLASS:lower()
  end
  local profs1, profs2, skip = { }, { }, {}
  local profs = profs1
  for _, p in ipairs(doc.PROFICIENCIES or {}) do
    if type(p) == 'table' and next(p) and next(p):find('skip') then
      if profs == profs1 then
        profs = profs2
      else
        profs = skip
      end
    elseif type(p) == 'string' then
      table.insert(profs, p)
    end
  end
  if not profs2[1] then profs2[1] = '?' end
  doc.THEPROFICIENCIES = stringf('{%s}{%s}', table.concat(profs1, [[\\]]),
                                             table.concat(profs2, [[\\]]))

  if nonempty(doc.MOTIVATION) then
    doc.THEMOTIVATION = doc.THEMOTIVATION or stringf([[\\\emph{%s}]], doc.MOTIVATION)
  else
    doc.THEMOTIVATION = doc.THEMOTIVATION or ''
  end

  doc.DMFEATURES = doc.DMFEATURES or doc.SENSES or ''
  
  doc.DESCRIPTION = doc.DESCRIPTION or ''

  doc.STATS = mkstats(doc)

  doc['SPELL DC'] = doc['SPELL DC'] or ''


  -- make underscores in template work like spaces
  for key in player_template:gmatch '%u+_[%u_]*%u' do
    doc[key] = doc[key] or doc[key:gsub('_', ' ')]
  end

  return player_template:gsub('%u[%u_]*', doc)
end

---------------------------------------------------------------------------
-- 5. Entry point
---------------------------------------------------------------------------
local function slurp(filename)
  if filename then
    local f = assert(io.open(filename, "r"))
    local txt = f:read("*a"); f:close(); return txt
  else
    return io.stdin:read("*a")
  end
end

local function extend(doc)
  local class = doc.CLASS or (doc['CLASS & LEVEL'] or ''):match '%a+' or ''
  doc.CLASS = class
  doc.LEVEL = doc.LEVEL or doc['CLASS & LEVEL']:match '%d+' or nil
  return doc
end

local function contents(filename)
  local f, msg = io.open(filename, 'r')
  if not f then return f, msg end
  local s, msg = f:read '*a'
  if not s then return s, string.format('%s: %s', filename, msg) end
  f:close()
  return s
end

local function set_contents(filename, s)
  local f, msg = io.open(filename, 'w')
  if not f then return f, msg end
  local s = assert(f:write(s))
  f:close()
  return s or true
end

local quote_me = '[^%w%+%-%=%@%_%/%.%:]' -- easier to complement what doesn't need quotes
local strfind = string.find

local function dirname(s) -- also returns basename as second result
  s = s:gsub('/$', '')
  local dir, base = s:match '^(.*)/([^/]*)$'
  if not dir then
    return '.', s
  elseif dir == '' then
    return '/', base
  else
    return dir, base
  end
end


function osquote(s)
  -- Returns string s with whatever markup is needed to quote it 
  -- to the POSIX shell.

  if strfind(s, quote_me) or s == '' then
    return "'" .. string.gsub(s, "'", [['"'"']]) .. "'"
  else
    return s
  end
end

local function fill_template(assignments)
  local pathname = stringf('%s/%s.tex', fields.templates, fields.type)
  local template, msg = contents(pathname)
  if not template then
    eprintf('%s\n', msg)
    os.exit(1)
  else
    local bracketed_splash = stringf('{%s/splash.png}', fields.templates)
    return (template:gsub('\n%s*\\input%b{}', assignments)
                    :gsub('%{splash.png%}', bracketed_splash)
           )
  end
end

local function emit(assignments)
  local output = fields.standalone and assignments or fill_template(assignments)

  if not fields.output then
    io.stdout:write(assignments, '\n')
  elseif fields.output:find '%.tex$' then
    set_contents(fields.output, output)
  elseif fields.output:find '%.pdf$' then
    local tex = fields.output:gsub('%.pdf$', '.tex')
    set_contents(tex, output)
    runf('pdflatex -output-directory %s %s', osquote(dirname(fields.output)), osquote(tex))
  end
end

local main = function(arg)
  for _, pathname in ipairs(arg) do
    local yaml_text = slurp(pathname)
    for _,doc in ipairs(yaml_load_all(yaml_text)) do
      if type(doc) == 'table' then
        io.stdout:write(mkplayer(extend(doc)), '\n\n')
      end
    end
  end
end


io.stdout:write [[
\documentclass[12pt,twocolumn]{article}
\usepackage[margin=0.8cm,landscape]{geometry}
\usepackage{times}
\usepackage{dminfo}

\begin{document}

]]

main(arg)

io.stdout:write [[
\end{document}
]]

